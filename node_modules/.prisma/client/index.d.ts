
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Tipo
 * 
 */
export type Tipo = {
  id: string
  nome: string
  tipoId: string | null
  ativo: boolean
}

/**
 * Model Pessoa
 * 
 */
export type Pessoa = {
  id: string
  nome: string
  documento: string | null
  razaoSocial: string | null
  nomeFantasia: string | null
  inscricaoMunicipal: string | null
  inscricaoEstadual: string | null
  nascimento: Date | null
  dataCadastro: Date
  dataAtualizado: Date | null
  ativo: boolean | null
  isAdmin: boolean | null
  tipoId: string | null
  empresaId: string | null
}

/**
 * Model PessoaTipo
 * 
 */
export type PessoaTipo = {
  id: string
  idTipo: string
  idPessoa: string
}

/**
 * Model Endereco
 * 
 */
export type Endereco = {
  id: string
  idTipo: string
  idPessoa: string
  cep: string
  local: string
  numero: string
  bairro: string
  complemento: string | null
  cidade: string
  estado: string
  ativo: boolean | null
  principal: boolean | null
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  idPessoa: string
  email: string
  password: string
  refreshToken: string | null
  dataCadastro: Date
  dataAtualizado: Date | null
  ativo: boolean | null
}

/**
 * Model UserEmpresa
 * 
 */
export type UserEmpresa = {
  id: string
  idPessoa: string
  idEmpresa: string
  pessoaId: string | null
}

/**
 * Model Permissao
 * 
 */
export type Permissao = {
  id: string
  idTipo: string
  idPessoa: string
  listar: boolean | null
  cadastrar: boolean | null
  editar: boolean | null
  excluir: boolean | null
}

/**
 * Model Contato
 * 
 */
export type Contato = {
  id: string
  idTipo: string
  idPessoa: string
  descricao: string
  ativo: boolean | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tipos
 * const tipos = await prisma.tipo.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tipos
   * const tipos = await prisma.tipo.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.tipo`: Exposes CRUD operations for the **Tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipos
    * const tipos = await prisma.tipo.findMany()
    * ```
    */
  get tipo(): Prisma.TipoDelegate<GlobalReject>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **Pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.PessoaDelegate<GlobalReject>;

  /**
   * `prisma.pessoaTipo`: Exposes CRUD operations for the **PessoaTipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaTipos
    * const pessoaTipos = await prisma.pessoaTipo.findMany()
    * ```
    */
  get pessoaTipo(): Prisma.PessoaTipoDelegate<GlobalReject>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **Endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.EnderecoDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userEmpresa`: Exposes CRUD operations for the **UserEmpresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEmpresas
    * const userEmpresas = await prisma.userEmpresa.findMany()
    * ```
    */
  get userEmpresa(): Prisma.UserEmpresaDelegate<GlobalReject>;

  /**
   * `prisma.permissao`: Exposes CRUD operations for the **Permissao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissaos
    * const permissaos = await prisma.permissao.findMany()
    * ```
    */
  get permissao(): Prisma.PermissaoDelegate<GlobalReject>;

  /**
   * `prisma.contato`: Exposes CRUD operations for the **Contato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contatoes
    * const contatoes = await prisma.contato.findMany()
    * ```
    */
  get contato(): Prisma.ContatoDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.12.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tipo: 'Tipo',
    Pessoa: 'Pessoa',
    PessoaTipo: 'PessoaTipo',
    Endereco: 'Endereco',
    User: 'User',
    UserEmpresa: 'UserEmpresa',
    Permissao: 'Permissao',
    Contato: 'Contato'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TipoCountOutputType
   */


  export type TipoCountOutputType = {
    Pessoa: number
    Endereco: number
    Permissao: number
    Contato: number
    PessoaTipo: number
    Tipos: number
  }

  export type TipoCountOutputTypeSelect = {
    Pessoa?: boolean
    Endereco?: boolean
    Permissao?: boolean
    Contato?: boolean
    PessoaTipo?: boolean
    Tipos?: boolean
  }

  export type TipoCountOutputTypeGetPayload<S extends boolean | null | undefined | TipoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TipoCountOutputTypeArgs)
    ? TipoCountOutputType 
    : S extends { select: any } & (TipoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TipoCountOutputType ? TipoCountOutputType[P] : never
  } 
      : TipoCountOutputType




  // Custom InputTypes

  /**
   * TipoCountOutputType without action
   */
  export type TipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TipoCountOutputType
     */
    select?: TipoCountOutputTypeSelect | null
  }



  /**
   * Count Type PessoaCountOutputType
   */


  export type PessoaCountOutputType = {
    Endereco: number
    User: number
    Permissao: number
    Contato: number
    PessoaTipo: number
    Empresa: number
    UserEmpresa: number
  }

  export type PessoaCountOutputTypeSelect = {
    Endereco?: boolean
    User?: boolean
    Permissao?: boolean
    Contato?: boolean
    PessoaTipo?: boolean
    Empresa?: boolean
    UserEmpresa?: boolean
  }

  export type PessoaCountOutputTypeGetPayload<S extends boolean | null | undefined | PessoaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PessoaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PessoaCountOutputTypeArgs)
    ? PessoaCountOutputType 
    : S extends { select: any } & (PessoaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PessoaCountOutputType ? PessoaCountOutputType[P] : never
  } 
      : PessoaCountOutputType




  // Custom InputTypes

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     */
    select?: PessoaCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Tipo
   */


  export type AggregateTipo = {
    _count: TipoCountAggregateOutputType | null
    _min: TipoMinAggregateOutputType | null
    _max: TipoMaxAggregateOutputType | null
  }

  export type TipoMinAggregateOutputType = {
    id: string | null
    nome: string | null
    tipoId: string | null
    ativo: boolean | null
  }

  export type TipoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    tipoId: string | null
    ativo: boolean | null
  }

  export type TipoCountAggregateOutputType = {
    id: number
    nome: number
    tipoId: number
    ativo: number
    _all: number
  }


  export type TipoMinAggregateInputType = {
    id?: true
    nome?: true
    tipoId?: true
    ativo?: true
  }

  export type TipoMaxAggregateInputType = {
    id?: true
    nome?: true
    tipoId?: true
    ativo?: true
  }

  export type TipoCountAggregateInputType = {
    id?: true
    nome?: true
    tipoId?: true
    ativo?: true
    _all?: true
  }

  export type TipoAggregateArgs = {
    /**
     * Filter which Tipo to aggregate.
     */
    where?: TipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipos to fetch.
     */
    orderBy?: Enumerable<TipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipos
    **/
    _count?: true | TipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoMaxAggregateInputType
  }

  export type GetTipoAggregateType<T extends TipoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo[P]>
      : GetScalarType<T[P], AggregateTipo[P]>
  }




  export type TipoGroupByArgs = {
    where?: TipoWhereInput
    orderBy?: Enumerable<TipoOrderByWithAggregationInput>
    by: TipoScalarFieldEnum[]
    having?: TipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoCountAggregateInputType | true
    _min?: TipoMinAggregateInputType
    _max?: TipoMaxAggregateInputType
  }


  export type TipoGroupByOutputType = {
    id: string
    nome: string
    tipoId: string | null
    ativo: boolean
    _count: TipoCountAggregateOutputType | null
    _min: TipoMinAggregateOutputType | null
    _max: TipoMaxAggregateOutputType | null
  }

  type GetTipoGroupByPayload<T extends TipoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoGroupByOutputType[P]>
        }
      >
    >


  export type TipoSelect = {
    id?: boolean
    nome?: boolean
    tipoId?: boolean
    ativo?: boolean
    Tipo?: boolean | TipoArgs
    Pessoa?: boolean | Tipo$PessoaArgs
    Endereco?: boolean | Tipo$EnderecoArgs
    Permissao?: boolean | Tipo$PermissaoArgs
    Contato?: boolean | Tipo$ContatoArgs
    PessoaTipo?: boolean | Tipo$PessoaTipoArgs
    Tipos?: boolean | Tipo$TiposArgs
    _count?: boolean | TipoCountOutputTypeArgs
  }


  export type TipoInclude = {
    Tipo?: boolean | TipoArgs
    Pessoa?: boolean | Tipo$PessoaArgs
    Endereco?: boolean | Tipo$EnderecoArgs
    Permissao?: boolean | Tipo$PermissaoArgs
    Contato?: boolean | Tipo$ContatoArgs
    PessoaTipo?: boolean | Tipo$PessoaTipoArgs
    Tipos?: boolean | Tipo$TiposArgs
    _count?: boolean | TipoCountOutputTypeArgs
  }

  export type TipoGetPayload<S extends boolean | null | undefined | TipoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tipo :
    S extends undefined ? never :
    S extends { include: any } & (TipoArgs | TipoFindManyArgs)
    ? Tipo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Tipo' ? TipoGetPayload<S['include'][P]> | null :
        P extends 'Pessoa' ? Array < PessoaGetPayload<S['include'][P]>>  :
        P extends 'Endereco' ? Array < EnderecoGetPayload<S['include'][P]>>  :
        P extends 'Permissao' ? Array < PermissaoGetPayload<S['include'][P]>>  :
        P extends 'Contato' ? Array < ContatoGetPayload<S['include'][P]>>  :
        P extends 'PessoaTipo' ? Array < PessoaTipoGetPayload<S['include'][P]>>  :
        P extends 'Tipos' ? Array < TipoGetPayload<S['include'][P]>>  :
        P extends '_count' ? TipoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TipoArgs | TipoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Tipo' ? TipoGetPayload<S['select'][P]> | null :
        P extends 'Pessoa' ? Array < PessoaGetPayload<S['select'][P]>>  :
        P extends 'Endereco' ? Array < EnderecoGetPayload<S['select'][P]>>  :
        P extends 'Permissao' ? Array < PermissaoGetPayload<S['select'][P]>>  :
        P extends 'Contato' ? Array < ContatoGetPayload<S['select'][P]>>  :
        P extends 'PessoaTipo' ? Array < PessoaTipoGetPayload<S['select'][P]>>  :
        P extends 'Tipos' ? Array < TipoGetPayload<S['select'][P]>>  :
        P extends '_count' ? TipoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tipo ? Tipo[P] : never
  } 
      : Tipo


  type TipoCountArgs = 
    Omit<TipoFindManyArgs, 'select' | 'include'> & {
      select?: TipoCountAggregateInputType | true
    }

  export interface TipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tipo that matches the filter.
     * @param {TipoFindUniqueArgs} args - Arguments to find a Tipo
     * @example
     * // Get one Tipo
     * const tipo = await prisma.tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tipo'> extends True ? Prisma__TipoClient<TipoGetPayload<T>> : Prisma__TipoClient<TipoGetPayload<T> | null, null>

    /**
     * Find one Tipo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TipoFindUniqueOrThrowArgs} args - Arguments to find a Tipo
     * @example
     * // Get one Tipo
     * const tipo = await prisma.tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TipoFindUniqueOrThrowArgs>
    ): Prisma__TipoClient<TipoGetPayload<T>>

    /**
     * Find the first Tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoFindFirstArgs} args - Arguments to find a Tipo
     * @example
     * // Get one Tipo
     * const tipo = await prisma.tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tipo'> extends True ? Prisma__TipoClient<TipoGetPayload<T>> : Prisma__TipoClient<TipoGetPayload<T> | null, null>

    /**
     * Find the first Tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoFindFirstOrThrowArgs} args - Arguments to find a Tipo
     * @example
     * // Get one Tipo
     * const tipo = await prisma.tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TipoFindFirstOrThrowArgs>
    ): Prisma__TipoClient<TipoGetPayload<T>>

    /**
     * Find zero or more Tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipos
     * const tipos = await prisma.tipo.findMany()
     * 
     * // Get first 10 Tipos
     * const tipos = await prisma.tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoWithIdOnly = await prisma.tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoFindManyArgs>(
      args?: SelectSubset<T, TipoFindManyArgs>
    ): Prisma.PrismaPromise<Array<TipoGetPayload<T>>>

    /**
     * Create a Tipo.
     * @param {TipoCreateArgs} args - Arguments to create a Tipo.
     * @example
     * // Create one Tipo
     * const Tipo = await prisma.tipo.create({
     *   data: {
     *     // ... data to create a Tipo
     *   }
     * })
     * 
    **/
    create<T extends TipoCreateArgs>(
      args: SelectSubset<T, TipoCreateArgs>
    ): Prisma__TipoClient<TipoGetPayload<T>>

    /**
     * Create many Tipos.
     *     @param {TipoCreateManyArgs} args - Arguments to create many Tipos.
     *     @example
     *     // Create many Tipos
     *     const tipo = await prisma.tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoCreateManyArgs>(
      args?: SelectSubset<T, TipoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo.
     * @param {TipoDeleteArgs} args - Arguments to delete one Tipo.
     * @example
     * // Delete one Tipo
     * const Tipo = await prisma.tipo.delete({
     *   where: {
     *     // ... filter to delete one Tipo
     *   }
     * })
     * 
    **/
    delete<T extends TipoDeleteArgs>(
      args: SelectSubset<T, TipoDeleteArgs>
    ): Prisma__TipoClient<TipoGetPayload<T>>

    /**
     * Update one Tipo.
     * @param {TipoUpdateArgs} args - Arguments to update one Tipo.
     * @example
     * // Update one Tipo
     * const tipo = await prisma.tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoUpdateArgs>(
      args: SelectSubset<T, TipoUpdateArgs>
    ): Prisma__TipoClient<TipoGetPayload<T>>

    /**
     * Delete zero or more Tipos.
     * @param {TipoDeleteManyArgs} args - Arguments to filter Tipos to delete.
     * @example
     * // Delete a few Tipos
     * const { count } = await prisma.tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoDeleteManyArgs>(
      args?: SelectSubset<T, TipoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipos
     * const tipo = await prisma.tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoUpdateManyArgs>(
      args: SelectSubset<T, TipoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo.
     * @param {TipoUpsertArgs} args - Arguments to update or create a Tipo.
     * @example
     * // Update or create a Tipo
     * const tipo = await prisma.tipo.upsert({
     *   create: {
     *     // ... data to create a Tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo we want to update
     *   }
     * })
    **/
    upsert<T extends TipoUpsertArgs>(
      args: SelectSubset<T, TipoUpsertArgs>
    ): Prisma__TipoClient<TipoGetPayload<T>>

    /**
     * Count the number of Tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCountArgs} args - Arguments to filter Tipos to count.
     * @example
     * // Count the number of Tipos
     * const count = await prisma.tipo.count({
     *   where: {
     *     // ... the filter for the Tipos we want to count
     *   }
     * })
    **/
    count<T extends TipoCountArgs>(
      args?: Subset<T, TipoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoAggregateArgs>(args: Subset<T, TipoAggregateArgs>): Prisma.PrismaPromise<GetTipoAggregateType<T>>

    /**
     * Group by Tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoGroupByArgs['orderBy'] }
        : { orderBy?: TipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Tipo<T extends TipoArgs= {}>(args?: Subset<T, TipoArgs>): Prisma__TipoClient<TipoGetPayload<T> | Null>;

    Pessoa<T extends Tipo$PessoaArgs= {}>(args?: Subset<T, Tipo$PessoaArgs>): Prisma.PrismaPromise<Array<PessoaGetPayload<T>>| Null>;

    Endereco<T extends Tipo$EnderecoArgs= {}>(args?: Subset<T, Tipo$EnderecoArgs>): Prisma.PrismaPromise<Array<EnderecoGetPayload<T>>| Null>;

    Permissao<T extends Tipo$PermissaoArgs= {}>(args?: Subset<T, Tipo$PermissaoArgs>): Prisma.PrismaPromise<Array<PermissaoGetPayload<T>>| Null>;

    Contato<T extends Tipo$ContatoArgs= {}>(args?: Subset<T, Tipo$ContatoArgs>): Prisma.PrismaPromise<Array<ContatoGetPayload<T>>| Null>;

    PessoaTipo<T extends Tipo$PessoaTipoArgs= {}>(args?: Subset<T, Tipo$PessoaTipoArgs>): Prisma.PrismaPromise<Array<PessoaTipoGetPayload<T>>| Null>;

    Tipos<T extends Tipo$TiposArgs= {}>(args?: Subset<T, Tipo$TiposArgs>): Prisma.PrismaPromise<Array<TipoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tipo base type for findUnique actions
   */
  export type TipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * Filter, which Tipo to fetch.
     */
    where: TipoWhereUniqueInput
  }

  /**
   * Tipo findUnique
   */
  export interface TipoFindUniqueArgs extends TipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tipo findUniqueOrThrow
   */
  export type TipoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * Filter, which Tipo to fetch.
     */
    where: TipoWhereUniqueInput
  }


  /**
   * Tipo base type for findFirst actions
   */
  export type TipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * Filter, which Tipo to fetch.
     */
    where?: TipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipos to fetch.
     */
    orderBy?: Enumerable<TipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipos.
     */
    cursor?: TipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipos.
     */
    distinct?: Enumerable<TipoScalarFieldEnum>
  }

  /**
   * Tipo findFirst
   */
  export interface TipoFindFirstArgs extends TipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tipo findFirstOrThrow
   */
  export type TipoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * Filter, which Tipo to fetch.
     */
    where?: TipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipos to fetch.
     */
    orderBy?: Enumerable<TipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipos.
     */
    cursor?: TipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipos.
     */
    distinct?: Enumerable<TipoScalarFieldEnum>
  }


  /**
   * Tipo findMany
   */
  export type TipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * Filter, which Tipos to fetch.
     */
    where?: TipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipos to fetch.
     */
    orderBy?: Enumerable<TipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipos.
     */
    cursor?: TipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipos.
     */
    skip?: number
    distinct?: Enumerable<TipoScalarFieldEnum>
  }


  /**
   * Tipo create
   */
  export type TipoCreateArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * The data needed to create a Tipo.
     */
    data: XOR<TipoCreateInput, TipoUncheckedCreateInput>
  }


  /**
   * Tipo createMany
   */
  export type TipoCreateManyArgs = {
    /**
     * The data used to create many Tipos.
     */
    data: Enumerable<TipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tipo update
   */
  export type TipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * The data needed to update a Tipo.
     */
    data: XOR<TipoUpdateInput, TipoUncheckedUpdateInput>
    /**
     * Choose, which Tipo to update.
     */
    where: TipoWhereUniqueInput
  }


  /**
   * Tipo updateMany
   */
  export type TipoUpdateManyArgs = {
    /**
     * The data used to update Tipos.
     */
    data: XOR<TipoUpdateManyMutationInput, TipoUncheckedUpdateManyInput>
    /**
     * Filter which Tipos to update
     */
    where?: TipoWhereInput
  }


  /**
   * Tipo upsert
   */
  export type TipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * The filter to search for the Tipo to update in case it exists.
     */
    where: TipoWhereUniqueInput
    /**
     * In case the Tipo found by the `where` argument doesn't exist, create a new Tipo with this data.
     */
    create: XOR<TipoCreateInput, TipoUncheckedCreateInput>
    /**
     * In case the Tipo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoUpdateInput, TipoUncheckedUpdateInput>
  }


  /**
   * Tipo delete
   */
  export type TipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    /**
     * Filter which Tipo to delete.
     */
    where: TipoWhereUniqueInput
  }


  /**
   * Tipo deleteMany
   */
  export type TipoDeleteManyArgs = {
    /**
     * Filter which Tipos to delete
     */
    where?: TipoWhereInput
  }


  /**
   * Tipo.Pessoa
   */
  export type Tipo$PessoaArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    where?: PessoaWhereInput
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    cursor?: PessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * Tipo.Endereco
   */
  export type Tipo$EnderecoArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    where?: EnderecoWhereInput
    orderBy?: Enumerable<EnderecoOrderByWithRelationInput>
    cursor?: EnderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EnderecoScalarFieldEnum>
  }


  /**
   * Tipo.Permissao
   */
  export type Tipo$PermissaoArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    where?: PermissaoWhereInput
    orderBy?: Enumerable<PermissaoOrderByWithRelationInput>
    cursor?: PermissaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PermissaoScalarFieldEnum>
  }


  /**
   * Tipo.Contato
   */
  export type Tipo$ContatoArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    where?: ContatoWhereInput
    orderBy?: Enumerable<ContatoOrderByWithRelationInput>
    cursor?: ContatoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ContatoScalarFieldEnum>
  }


  /**
   * Tipo.PessoaTipo
   */
  export type Tipo$PessoaTipoArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    where?: PessoaTipoWhereInput
    orderBy?: Enumerable<PessoaTipoOrderByWithRelationInput>
    cursor?: PessoaTipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PessoaTipoScalarFieldEnum>
  }


  /**
   * Tipo.Tipos
   */
  export type Tipo$TiposArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
    where?: TipoWhereInput
    orderBy?: Enumerable<TipoOrderByWithRelationInput>
    cursor?: TipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TipoScalarFieldEnum>
  }


  /**
   * Tipo without action
   */
  export type TipoArgs = {
    /**
     * Select specific fields to fetch from the Tipo
     */
    select?: TipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TipoInclude | null
  }



  /**
   * Model Pessoa
   */


  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaMinAggregateOutputType = {
    id: string | null
    nome: string | null
    documento: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    inscricaoMunicipal: string | null
    inscricaoEstadual: string | null
    nascimento: Date | null
    dataCadastro: Date | null
    dataAtualizado: Date | null
    ativo: boolean | null
    isAdmin: boolean | null
    tipoId: string | null
    empresaId: string | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    documento: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    inscricaoMunicipal: string | null
    inscricaoEstadual: string | null
    nascimento: Date | null
    dataCadastro: Date | null
    dataAtualizado: Date | null
    ativo: boolean | null
    isAdmin: boolean | null
    tipoId: string | null
    empresaId: string | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    nome: number
    documento: number
    razaoSocial: number
    nomeFantasia: number
    inscricaoMunicipal: number
    inscricaoEstadual: number
    nascimento: number
    dataCadastro: number
    dataAtualizado: number
    ativo: number
    isAdmin: number
    tipoId: number
    empresaId: number
    _all: number
  }


  export type PessoaMinAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    razaoSocial?: true
    nomeFantasia?: true
    inscricaoMunicipal?: true
    inscricaoEstadual?: true
    nascimento?: true
    dataCadastro?: true
    dataAtualizado?: true
    ativo?: true
    isAdmin?: true
    tipoId?: true
    empresaId?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    razaoSocial?: true
    nomeFantasia?: true
    inscricaoMunicipal?: true
    inscricaoEstadual?: true
    nascimento?: true
    dataCadastro?: true
    dataAtualizado?: true
    ativo?: true
    isAdmin?: true
    tipoId?: true
    empresaId?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    razaoSocial?: true
    nomeFantasia?: true
    inscricaoMunicipal?: true
    inscricaoEstadual?: true
    nascimento?: true
    dataCadastro?: true
    dataAtualizado?: true
    ativo?: true
    isAdmin?: true
    tipoId?: true
    empresaId?: true
    _all?: true
  }

  export type PessoaAggregateArgs = {
    /**
     * Filter which Pessoa to aggregate.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type PessoaGroupByArgs = {
    where?: PessoaWhereInput
    orderBy?: Enumerable<PessoaOrderByWithAggregationInput>
    by: PessoaScalarFieldEnum[]
    having?: PessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }


  export type PessoaGroupByOutputType = {
    id: string
    nome: string
    documento: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    inscricaoMunicipal: string | null
    inscricaoEstadual: string | null
    nascimento: Date | null
    dataCadastro: Date
    dataAtualizado: Date | null
    ativo: boolean | null
    isAdmin: boolean | null
    tipoId: string | null
    empresaId: string | null
    _count: PessoaCountAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends PessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type PessoaSelect = {
    id?: boolean
    nome?: boolean
    documento?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    inscricaoMunicipal?: boolean
    inscricaoEstadual?: boolean
    nascimento?: boolean
    dataCadastro?: boolean
    dataAtualizado?: boolean
    ativo?: boolean
    isAdmin?: boolean
    tipoId?: boolean
    empresaId?: boolean
    Endereco?: boolean | Pessoa$EnderecoArgs
    User?: boolean | Pessoa$UserArgs
    Permissao?: boolean | Pessoa$PermissaoArgs
    Contato?: boolean | Pessoa$ContatoArgs
    Tipo?: boolean | TipoArgs
    PessoaTipo?: boolean | Pessoa$PessoaTipoArgs
    empresa?: boolean | PessoaArgs
    Empresa?: boolean | Pessoa$EmpresaArgs
    UserEmpresa?: boolean | Pessoa$UserEmpresaArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  }


  export type PessoaInclude = {
    Endereco?: boolean | Pessoa$EnderecoArgs
    User?: boolean | Pessoa$UserArgs
    Permissao?: boolean | Pessoa$PermissaoArgs
    Contato?: boolean | Pessoa$ContatoArgs
    Tipo?: boolean | TipoArgs
    PessoaTipo?: boolean | Pessoa$PessoaTipoArgs
    empresa?: boolean | PessoaArgs
    Empresa?: boolean | Pessoa$EmpresaArgs
    UserEmpresa?: boolean | Pessoa$UserEmpresaArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  }

  export type PessoaGetPayload<S extends boolean | null | undefined | PessoaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pessoa :
    S extends undefined ? never :
    S extends { include: any } & (PessoaArgs | PessoaFindManyArgs)
    ? Pessoa  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Endereco' ? Array < EnderecoGetPayload<S['include'][P]>>  :
        P extends 'User' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'Permissao' ? Array < PermissaoGetPayload<S['include'][P]>>  :
        P extends 'Contato' ? Array < ContatoGetPayload<S['include'][P]>>  :
        P extends 'Tipo' ? TipoGetPayload<S['include'][P]> | null :
        P extends 'PessoaTipo' ? Array < PessoaTipoGetPayload<S['include'][P]>>  :
        P extends 'empresa' ? PessoaGetPayload<S['include'][P]> | null :
        P extends 'Empresa' ? Array < PessoaGetPayload<S['include'][P]>>  :
        P extends 'UserEmpresa' ? Array < UserEmpresaGetPayload<S['include'][P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PessoaArgs | PessoaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Endereco' ? Array < EnderecoGetPayload<S['select'][P]>>  :
        P extends 'User' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'Permissao' ? Array < PermissaoGetPayload<S['select'][P]>>  :
        P extends 'Contato' ? Array < ContatoGetPayload<S['select'][P]>>  :
        P extends 'Tipo' ? TipoGetPayload<S['select'][P]> | null :
        P extends 'PessoaTipo' ? Array < PessoaTipoGetPayload<S['select'][P]>>  :
        P extends 'empresa' ? PessoaGetPayload<S['select'][P]> | null :
        P extends 'Empresa' ? Array < PessoaGetPayload<S['select'][P]>>  :
        P extends 'UserEmpresa' ? Array < UserEmpresaGetPayload<S['select'][P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Pessoa ? Pessoa[P] : never
  } 
      : Pessoa


  type PessoaCountArgs = 
    Omit<PessoaFindManyArgs, 'select' | 'include'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface PessoaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {PessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PessoaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PessoaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pessoa'> extends True ? Prisma__PessoaClient<PessoaGetPayload<T>> : Prisma__PessoaClient<PessoaGetPayload<T> | null, null>

    /**
     * Find one Pessoa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PessoaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PessoaFindUniqueOrThrowArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PessoaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PessoaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pessoa'> extends True ? Prisma__PessoaClient<PessoaGetPayload<T>> : Prisma__PessoaClient<PessoaGetPayload<T> | null, null>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PessoaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PessoaFindFirstOrThrowArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PessoaFindManyArgs>(
      args?: SelectSubset<T, PessoaFindManyArgs>
    ): Prisma.PrismaPromise<Array<PessoaGetPayload<T>>>

    /**
     * Create a Pessoa.
     * @param {PessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
    **/
    create<T extends PessoaCreateArgs>(
      args: SelectSubset<T, PessoaCreateArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Create many Pessoas.
     *     @param {PessoaCreateManyArgs} args - Arguments to create many Pessoas.
     *     @example
     *     // Create many Pessoas
     *     const pessoa = await prisma.pessoa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PessoaCreateManyArgs>(
      args?: SelectSubset<T, PessoaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pessoa.
     * @param {PessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
    **/
    delete<T extends PessoaDeleteArgs>(
      args: SelectSubset<T, PessoaDeleteArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Update one Pessoa.
     * @param {PessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PessoaUpdateArgs>(
      args: SelectSubset<T, PessoaUpdateArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Delete zero or more Pessoas.
     * @param {PessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PessoaDeleteManyArgs>(
      args?: SelectSubset<T, PessoaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PessoaUpdateManyArgs>(
      args: SelectSubset<T, PessoaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {PessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
    **/
    upsert<T extends PessoaUpsertArgs>(
      args: SelectSubset<T, PessoaUpsertArgs>
    ): Prisma__PessoaClient<PessoaGetPayload<T>>

    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends PessoaCountArgs>(
      args?: Subset<T, PessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PessoaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Endereco<T extends Pessoa$EnderecoArgs= {}>(args?: Subset<T, Pessoa$EnderecoArgs>): Prisma.PrismaPromise<Array<EnderecoGetPayload<T>>| Null>;

    User<T extends Pessoa$UserArgs= {}>(args?: Subset<T, Pessoa$UserArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    Permissao<T extends Pessoa$PermissaoArgs= {}>(args?: Subset<T, Pessoa$PermissaoArgs>): Prisma.PrismaPromise<Array<PermissaoGetPayload<T>>| Null>;

    Contato<T extends Pessoa$ContatoArgs= {}>(args?: Subset<T, Pessoa$ContatoArgs>): Prisma.PrismaPromise<Array<ContatoGetPayload<T>>| Null>;

    Tipo<T extends TipoArgs= {}>(args?: Subset<T, TipoArgs>): Prisma__TipoClient<TipoGetPayload<T> | Null>;

    PessoaTipo<T extends Pessoa$PessoaTipoArgs= {}>(args?: Subset<T, Pessoa$PessoaTipoArgs>): Prisma.PrismaPromise<Array<PessoaTipoGetPayload<T>>| Null>;

    empresa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    Empresa<T extends Pessoa$EmpresaArgs= {}>(args?: Subset<T, Pessoa$EmpresaArgs>): Prisma.PrismaPromise<Array<PessoaGetPayload<T>>| Null>;

    UserEmpresa<T extends Pessoa$UserEmpresaArgs= {}>(args?: Subset<T, Pessoa$UserEmpresaArgs>): Prisma.PrismaPromise<Array<UserEmpresaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pessoa base type for findUnique actions
   */
  export type PessoaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa findUnique
   */
  export interface PessoaFindUniqueArgs extends PessoaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pessoa findUniqueOrThrow
   */
  export type PessoaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }


  /**
   * Pessoa base type for findFirst actions
   */
  export type PessoaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }

  /**
   * Pessoa findFirst
   */
  export interface PessoaFindFirstArgs extends PessoaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pessoa findFirstOrThrow
   */
  export type PessoaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * Pessoa findMany
   */
  export type PessoaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter, which Pessoas to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * Pessoa create
   */
  export type PessoaCreateArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * The data needed to create a Pessoa.
     */
    data: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
  }


  /**
   * Pessoa createMany
   */
  export type PessoaCreateManyArgs = {
    /**
     * The data used to create many Pessoas.
     */
    data: Enumerable<PessoaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pessoa update
   */
  export type PessoaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * The data needed to update a Pessoa.
     */
    data: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
    /**
     * Choose, which Pessoa to update.
     */
    where: PessoaWhereUniqueInput
  }


  /**
   * Pessoa updateMany
   */
  export type PessoaUpdateManyArgs = {
    /**
     * The data used to update Pessoas.
     */
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyInput>
    /**
     * Filter which Pessoas to update
     */
    where?: PessoaWhereInput
  }


  /**
   * Pessoa upsert
   */
  export type PessoaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * The filter to search for the Pessoa to update in case it exists.
     */
    where: PessoaWhereUniqueInput
    /**
     * In case the Pessoa found by the `where` argument doesn't exist, create a new Pessoa with this data.
     */
    create: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
    /**
     * In case the Pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
  }


  /**
   * Pessoa delete
   */
  export type PessoaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    /**
     * Filter which Pessoa to delete.
     */
    where: PessoaWhereUniqueInput
  }


  /**
   * Pessoa deleteMany
   */
  export type PessoaDeleteManyArgs = {
    /**
     * Filter which Pessoas to delete
     */
    where?: PessoaWhereInput
  }


  /**
   * Pessoa.Endereco
   */
  export type Pessoa$EnderecoArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    where?: EnderecoWhereInput
    orderBy?: Enumerable<EnderecoOrderByWithRelationInput>
    cursor?: EnderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EnderecoScalarFieldEnum>
  }


  /**
   * Pessoa.User
   */
  export type Pessoa$UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Pessoa.Permissao
   */
  export type Pessoa$PermissaoArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    where?: PermissaoWhereInput
    orderBy?: Enumerable<PermissaoOrderByWithRelationInput>
    cursor?: PermissaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PermissaoScalarFieldEnum>
  }


  /**
   * Pessoa.Contato
   */
  export type Pessoa$ContatoArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    where?: ContatoWhereInput
    orderBy?: Enumerable<ContatoOrderByWithRelationInput>
    cursor?: ContatoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ContatoScalarFieldEnum>
  }


  /**
   * Pessoa.PessoaTipo
   */
  export type Pessoa$PessoaTipoArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    where?: PessoaTipoWhereInput
    orderBy?: Enumerable<PessoaTipoOrderByWithRelationInput>
    cursor?: PessoaTipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PessoaTipoScalarFieldEnum>
  }


  /**
   * Pessoa.Empresa
   */
  export type Pessoa$EmpresaArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
    where?: PessoaWhereInput
    orderBy?: Enumerable<PessoaOrderByWithRelationInput>
    cursor?: PessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * Pessoa.UserEmpresa
   */
  export type Pessoa$UserEmpresaArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    where?: UserEmpresaWhereInput
    orderBy?: Enumerable<UserEmpresaOrderByWithRelationInput>
    cursor?: UserEmpresaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserEmpresaScalarFieldEnum>
  }


  /**
   * Pessoa without action
   */
  export type PessoaArgs = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaInclude | null
  }



  /**
   * Model PessoaTipo
   */


  export type AggregatePessoaTipo = {
    _count: PessoaTipoCountAggregateOutputType | null
    _min: PessoaTipoMinAggregateOutputType | null
    _max: PessoaTipoMaxAggregateOutputType | null
  }

  export type PessoaTipoMinAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
  }

  export type PessoaTipoMaxAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
  }

  export type PessoaTipoCountAggregateOutputType = {
    id: number
    idTipo: number
    idPessoa: number
    _all: number
  }


  export type PessoaTipoMinAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
  }

  export type PessoaTipoMaxAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
  }

  export type PessoaTipoCountAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    _all?: true
  }

  export type PessoaTipoAggregateArgs = {
    /**
     * Filter which PessoaTipo to aggregate.
     */
    where?: PessoaTipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaTipos to fetch.
     */
    orderBy?: Enumerable<PessoaTipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaTipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaTipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaTipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PessoaTipos
    **/
    _count?: true | PessoaTipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaTipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaTipoMaxAggregateInputType
  }

  export type GetPessoaTipoAggregateType<T extends PessoaTipoAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaTipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaTipo[P]>
      : GetScalarType<T[P], AggregatePessoaTipo[P]>
  }




  export type PessoaTipoGroupByArgs = {
    where?: PessoaTipoWhereInput
    orderBy?: Enumerable<PessoaTipoOrderByWithAggregationInput>
    by: PessoaTipoScalarFieldEnum[]
    having?: PessoaTipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaTipoCountAggregateInputType | true
    _min?: PessoaTipoMinAggregateInputType
    _max?: PessoaTipoMaxAggregateInputType
  }


  export type PessoaTipoGroupByOutputType = {
    id: string
    idTipo: string
    idPessoa: string
    _count: PessoaTipoCountAggregateOutputType | null
    _min: PessoaTipoMinAggregateOutputType | null
    _max: PessoaTipoMaxAggregateOutputType | null
  }

  type GetPessoaTipoGroupByPayload<T extends PessoaTipoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PessoaTipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaTipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaTipoGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaTipoGroupByOutputType[P]>
        }
      >
    >


  export type PessoaTipoSelect = {
    id?: boolean
    idTipo?: boolean
    idPessoa?: boolean
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }


  export type PessoaTipoInclude = {
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }

  export type PessoaTipoGetPayload<S extends boolean | null | undefined | PessoaTipoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PessoaTipo :
    S extends undefined ? never :
    S extends { include: any } & (PessoaTipoArgs | PessoaTipoFindManyArgs)
    ? PessoaTipo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tipo' ? TipoGetPayload<S['include'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PessoaTipoArgs | PessoaTipoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tipo' ? TipoGetPayload<S['select'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['select'][P]> :  P extends keyof PessoaTipo ? PessoaTipo[P] : never
  } 
      : PessoaTipo


  type PessoaTipoCountArgs = 
    Omit<PessoaTipoFindManyArgs, 'select' | 'include'> & {
      select?: PessoaTipoCountAggregateInputType | true
    }

  export interface PessoaTipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PessoaTipo that matches the filter.
     * @param {PessoaTipoFindUniqueArgs} args - Arguments to find a PessoaTipo
     * @example
     * // Get one PessoaTipo
     * const pessoaTipo = await prisma.pessoaTipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PessoaTipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PessoaTipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PessoaTipo'> extends True ? Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>> : Prisma__PessoaTipoClient<PessoaTipoGetPayload<T> | null, null>

    /**
     * Find one PessoaTipo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PessoaTipoFindUniqueOrThrowArgs} args - Arguments to find a PessoaTipo
     * @example
     * // Get one PessoaTipo
     * const pessoaTipo = await prisma.pessoaTipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PessoaTipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PessoaTipoFindUniqueOrThrowArgs>
    ): Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>>

    /**
     * Find the first PessoaTipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoFindFirstArgs} args - Arguments to find a PessoaTipo
     * @example
     * // Get one PessoaTipo
     * const pessoaTipo = await prisma.pessoaTipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PessoaTipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PessoaTipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PessoaTipo'> extends True ? Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>> : Prisma__PessoaTipoClient<PessoaTipoGetPayload<T> | null, null>

    /**
     * Find the first PessoaTipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoFindFirstOrThrowArgs} args - Arguments to find a PessoaTipo
     * @example
     * // Get one PessoaTipo
     * const pessoaTipo = await prisma.pessoaTipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PessoaTipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PessoaTipoFindFirstOrThrowArgs>
    ): Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>>

    /**
     * Find zero or more PessoaTipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaTipos
     * const pessoaTipos = await prisma.pessoaTipo.findMany()
     * 
     * // Get first 10 PessoaTipos
     * const pessoaTipos = await prisma.pessoaTipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaTipoWithIdOnly = await prisma.pessoaTipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PessoaTipoFindManyArgs>(
      args?: SelectSubset<T, PessoaTipoFindManyArgs>
    ): Prisma.PrismaPromise<Array<PessoaTipoGetPayload<T>>>

    /**
     * Create a PessoaTipo.
     * @param {PessoaTipoCreateArgs} args - Arguments to create a PessoaTipo.
     * @example
     * // Create one PessoaTipo
     * const PessoaTipo = await prisma.pessoaTipo.create({
     *   data: {
     *     // ... data to create a PessoaTipo
     *   }
     * })
     * 
    **/
    create<T extends PessoaTipoCreateArgs>(
      args: SelectSubset<T, PessoaTipoCreateArgs>
    ): Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>>

    /**
     * Create many PessoaTipos.
     *     @param {PessoaTipoCreateManyArgs} args - Arguments to create many PessoaTipos.
     *     @example
     *     // Create many PessoaTipos
     *     const pessoaTipo = await prisma.pessoaTipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PessoaTipoCreateManyArgs>(
      args?: SelectSubset<T, PessoaTipoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PessoaTipo.
     * @param {PessoaTipoDeleteArgs} args - Arguments to delete one PessoaTipo.
     * @example
     * // Delete one PessoaTipo
     * const PessoaTipo = await prisma.pessoaTipo.delete({
     *   where: {
     *     // ... filter to delete one PessoaTipo
     *   }
     * })
     * 
    **/
    delete<T extends PessoaTipoDeleteArgs>(
      args: SelectSubset<T, PessoaTipoDeleteArgs>
    ): Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>>

    /**
     * Update one PessoaTipo.
     * @param {PessoaTipoUpdateArgs} args - Arguments to update one PessoaTipo.
     * @example
     * // Update one PessoaTipo
     * const pessoaTipo = await prisma.pessoaTipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PessoaTipoUpdateArgs>(
      args: SelectSubset<T, PessoaTipoUpdateArgs>
    ): Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>>

    /**
     * Delete zero or more PessoaTipos.
     * @param {PessoaTipoDeleteManyArgs} args - Arguments to filter PessoaTipos to delete.
     * @example
     * // Delete a few PessoaTipos
     * const { count } = await prisma.pessoaTipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PessoaTipoDeleteManyArgs>(
      args?: SelectSubset<T, PessoaTipoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaTipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaTipos
     * const pessoaTipo = await prisma.pessoaTipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PessoaTipoUpdateManyArgs>(
      args: SelectSubset<T, PessoaTipoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PessoaTipo.
     * @param {PessoaTipoUpsertArgs} args - Arguments to update or create a PessoaTipo.
     * @example
     * // Update or create a PessoaTipo
     * const pessoaTipo = await prisma.pessoaTipo.upsert({
     *   create: {
     *     // ... data to create a PessoaTipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaTipo we want to update
     *   }
     * })
    **/
    upsert<T extends PessoaTipoUpsertArgs>(
      args: SelectSubset<T, PessoaTipoUpsertArgs>
    ): Prisma__PessoaTipoClient<PessoaTipoGetPayload<T>>

    /**
     * Count the number of PessoaTipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoCountArgs} args - Arguments to filter PessoaTipos to count.
     * @example
     * // Count the number of PessoaTipos
     * const count = await prisma.pessoaTipo.count({
     *   where: {
     *     // ... the filter for the PessoaTipos we want to count
     *   }
     * })
    **/
    count<T extends PessoaTipoCountArgs>(
      args?: Subset<T, PessoaTipoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaTipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaTipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaTipoAggregateArgs>(args: Subset<T, PessoaTipoAggregateArgs>): Prisma.PrismaPromise<GetPessoaTipoAggregateType<T>>

    /**
     * Group by PessoaTipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaTipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaTipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaTipoGroupByArgs['orderBy'] }
        : { orderBy?: PessoaTipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaTipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaTipoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PessoaTipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PessoaTipoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tipo<T extends TipoArgs= {}>(args?: Subset<T, TipoArgs>): Prisma__TipoClient<TipoGetPayload<T> | Null>;

    pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PessoaTipo base type for findUnique actions
   */
  export type PessoaTipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * Filter, which PessoaTipo to fetch.
     */
    where: PessoaTipoWhereUniqueInput
  }

  /**
   * PessoaTipo findUnique
   */
  export interface PessoaTipoFindUniqueArgs extends PessoaTipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PessoaTipo findUniqueOrThrow
   */
  export type PessoaTipoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * Filter, which PessoaTipo to fetch.
     */
    where: PessoaTipoWhereUniqueInput
  }


  /**
   * PessoaTipo base type for findFirst actions
   */
  export type PessoaTipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * Filter, which PessoaTipo to fetch.
     */
    where?: PessoaTipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaTipos to fetch.
     */
    orderBy?: Enumerable<PessoaTipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PessoaTipos.
     */
    cursor?: PessoaTipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaTipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaTipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PessoaTipos.
     */
    distinct?: Enumerable<PessoaTipoScalarFieldEnum>
  }

  /**
   * PessoaTipo findFirst
   */
  export interface PessoaTipoFindFirstArgs extends PessoaTipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PessoaTipo findFirstOrThrow
   */
  export type PessoaTipoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * Filter, which PessoaTipo to fetch.
     */
    where?: PessoaTipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaTipos to fetch.
     */
    orderBy?: Enumerable<PessoaTipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PessoaTipos.
     */
    cursor?: PessoaTipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaTipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaTipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PessoaTipos.
     */
    distinct?: Enumerable<PessoaTipoScalarFieldEnum>
  }


  /**
   * PessoaTipo findMany
   */
  export type PessoaTipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * Filter, which PessoaTipos to fetch.
     */
    where?: PessoaTipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaTipos to fetch.
     */
    orderBy?: Enumerable<PessoaTipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PessoaTipos.
     */
    cursor?: PessoaTipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaTipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaTipos.
     */
    skip?: number
    distinct?: Enumerable<PessoaTipoScalarFieldEnum>
  }


  /**
   * PessoaTipo create
   */
  export type PessoaTipoCreateArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * The data needed to create a PessoaTipo.
     */
    data: XOR<PessoaTipoCreateInput, PessoaTipoUncheckedCreateInput>
  }


  /**
   * PessoaTipo createMany
   */
  export type PessoaTipoCreateManyArgs = {
    /**
     * The data used to create many PessoaTipos.
     */
    data: Enumerable<PessoaTipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PessoaTipo update
   */
  export type PessoaTipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * The data needed to update a PessoaTipo.
     */
    data: XOR<PessoaTipoUpdateInput, PessoaTipoUncheckedUpdateInput>
    /**
     * Choose, which PessoaTipo to update.
     */
    where: PessoaTipoWhereUniqueInput
  }


  /**
   * PessoaTipo updateMany
   */
  export type PessoaTipoUpdateManyArgs = {
    /**
     * The data used to update PessoaTipos.
     */
    data: XOR<PessoaTipoUpdateManyMutationInput, PessoaTipoUncheckedUpdateManyInput>
    /**
     * Filter which PessoaTipos to update
     */
    where?: PessoaTipoWhereInput
  }


  /**
   * PessoaTipo upsert
   */
  export type PessoaTipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * The filter to search for the PessoaTipo to update in case it exists.
     */
    where: PessoaTipoWhereUniqueInput
    /**
     * In case the PessoaTipo found by the `where` argument doesn't exist, create a new PessoaTipo with this data.
     */
    create: XOR<PessoaTipoCreateInput, PessoaTipoUncheckedCreateInput>
    /**
     * In case the PessoaTipo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaTipoUpdateInput, PessoaTipoUncheckedUpdateInput>
  }


  /**
   * PessoaTipo delete
   */
  export type PessoaTipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
    /**
     * Filter which PessoaTipo to delete.
     */
    where: PessoaTipoWhereUniqueInput
  }


  /**
   * PessoaTipo deleteMany
   */
  export type PessoaTipoDeleteManyArgs = {
    /**
     * Filter which PessoaTipos to delete
     */
    where?: PessoaTipoWhereInput
  }


  /**
   * PessoaTipo without action
   */
  export type PessoaTipoArgs = {
    /**
     * Select specific fields to fetch from the PessoaTipo
     */
    select?: PessoaTipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PessoaTipoInclude | null
  }



  /**
   * Model Endereco
   */


  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoMinAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
    cep: string | null
    local: string | null
    numero: string | null
    bairro: string | null
    complemento: string | null
    cidade: string | null
    estado: string | null
    ativo: boolean | null
    principal: boolean | null
  }

  export type EnderecoMaxAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
    cep: string | null
    local: string | null
    numero: string | null
    bairro: string | null
    complemento: string | null
    cidade: string | null
    estado: string | null
    ativo: boolean | null
    principal: boolean | null
  }

  export type EnderecoCountAggregateOutputType = {
    id: number
    idTipo: number
    idPessoa: number
    cep: number
    local: number
    numero: number
    bairro: number
    complemento: number
    cidade: number
    estado: number
    ativo: number
    principal: number
    _all: number
  }


  export type EnderecoMinAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    cep?: true
    local?: true
    numero?: true
    bairro?: true
    complemento?: true
    cidade?: true
    estado?: true
    ativo?: true
    principal?: true
  }

  export type EnderecoMaxAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    cep?: true
    local?: true
    numero?: true
    bairro?: true
    complemento?: true
    cidade?: true
    estado?: true
    ativo?: true
    principal?: true
  }

  export type EnderecoCountAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    cep?: true
    local?: true
    numero?: true
    bairro?: true
    complemento?: true
    cidade?: true
    estado?: true
    ativo?: true
    principal?: true
    _all?: true
  }

  export type EnderecoAggregateArgs = {
    /**
     * Filter which Endereco to aggregate.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: Enumerable<EnderecoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type EnderecoGroupByArgs = {
    where?: EnderecoWhereInput
    orderBy?: Enumerable<EnderecoOrderByWithAggregationInput>
    by: EnderecoScalarFieldEnum[]
    having?: EnderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }


  export type EnderecoGroupByOutputType = {
    id: string
    idTipo: string
    idPessoa: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento: string | null
    cidade: string
    estado: string
    ativo: boolean | null
    principal: boolean | null
    _count: EnderecoCountAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends EnderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoSelect = {
    id?: boolean
    idTipo?: boolean
    idPessoa?: boolean
    cep?: boolean
    local?: boolean
    numero?: boolean
    bairro?: boolean
    complemento?: boolean
    cidade?: boolean
    estado?: boolean
    ativo?: boolean
    principal?: boolean
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }


  export type EnderecoInclude = {
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }

  export type EnderecoGetPayload<S extends boolean | null | undefined | EnderecoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Endereco :
    S extends undefined ? never :
    S extends { include: any } & (EnderecoArgs | EnderecoFindManyArgs)
    ? Endereco  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tipo' ? TipoGetPayload<S['include'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EnderecoArgs | EnderecoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tipo' ? TipoGetPayload<S['select'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['select'][P]> :  P extends keyof Endereco ? Endereco[P] : never
  } 
      : Endereco


  type EnderecoCountArgs = 
    Omit<EnderecoFindManyArgs, 'select' | 'include'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface EnderecoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Endereco that matches the filter.
     * @param {EnderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnderecoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EnderecoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Endereco'> extends True ? Prisma__EnderecoClient<EnderecoGetPayload<T>> : Prisma__EnderecoClient<EnderecoGetPayload<T> | null, null>

    /**
     * Find one Endereco that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnderecoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EnderecoFindUniqueOrThrowArgs>
    ): Prisma__EnderecoClient<EnderecoGetPayload<T>>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnderecoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EnderecoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Endereco'> extends True ? Prisma__EnderecoClient<EnderecoGetPayload<T>> : Prisma__EnderecoClient<EnderecoGetPayload<T> | null, null>

    /**
     * Find the first Endereco that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnderecoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EnderecoFindFirstOrThrowArgs>
    ): Prisma__EnderecoClient<EnderecoGetPayload<T>>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoWithIdOnly = await prisma.endereco.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnderecoFindManyArgs>(
      args?: SelectSubset<T, EnderecoFindManyArgs>
    ): Prisma.PrismaPromise<Array<EnderecoGetPayload<T>>>

    /**
     * Create a Endereco.
     * @param {EnderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
    **/
    create<T extends EnderecoCreateArgs>(
      args: SelectSubset<T, EnderecoCreateArgs>
    ): Prisma__EnderecoClient<EnderecoGetPayload<T>>

    /**
     * Create many Enderecos.
     *     @param {EnderecoCreateManyArgs} args - Arguments to create many Enderecos.
     *     @example
     *     // Create many Enderecos
     *     const endereco = await prisma.endereco.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnderecoCreateManyArgs>(
      args?: SelectSubset<T, EnderecoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Endereco.
     * @param {EnderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
    **/
    delete<T extends EnderecoDeleteArgs>(
      args: SelectSubset<T, EnderecoDeleteArgs>
    ): Prisma__EnderecoClient<EnderecoGetPayload<T>>

    /**
     * Update one Endereco.
     * @param {EnderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnderecoUpdateArgs>(
      args: SelectSubset<T, EnderecoUpdateArgs>
    ): Prisma__EnderecoClient<EnderecoGetPayload<T>>

    /**
     * Delete zero or more Enderecos.
     * @param {EnderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnderecoDeleteManyArgs>(
      args?: SelectSubset<T, EnderecoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnderecoUpdateManyArgs>(
      args: SelectSubset<T, EnderecoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Endereco.
     * @param {EnderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
    **/
    upsert<T extends EnderecoUpsertArgs>(
      args: SelectSubset<T, EnderecoUpsertArgs>
    ): Prisma__EnderecoClient<EnderecoGetPayload<T>>

    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends EnderecoCountArgs>(
      args?: Subset<T, EnderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnderecoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tipo<T extends TipoArgs= {}>(args?: Subset<T, TipoArgs>): Prisma__TipoClient<TipoGetPayload<T> | Null>;

    pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Endereco base type for findUnique actions
   */
  export type EnderecoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findUnique
   */
  export interface EnderecoFindUniqueArgs extends EnderecoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Endereco findUniqueOrThrow
   */
  export type EnderecoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco base type for findFirst actions
   */
  export type EnderecoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: Enumerable<EnderecoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: Enumerable<EnderecoScalarFieldEnum>
  }

  /**
   * Endereco findFirst
   */
  export interface EnderecoFindFirstArgs extends EnderecoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Endereco findFirstOrThrow
   */
  export type EnderecoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: Enumerable<EnderecoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: Enumerable<EnderecoScalarFieldEnum>
  }


  /**
   * Endereco findMany
   */
  export type EnderecoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * Filter, which Enderecos to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: Enumerable<EnderecoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    distinct?: Enumerable<EnderecoScalarFieldEnum>
  }


  /**
   * Endereco create
   */
  export type EnderecoCreateArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * The data needed to create a Endereco.
     */
    data: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
  }


  /**
   * Endereco createMany
   */
  export type EnderecoCreateManyArgs = {
    /**
     * The data used to create many Enderecos.
     */
    data: Enumerable<EnderecoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Endereco update
   */
  export type EnderecoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * The data needed to update a Endereco.
     */
    data: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
    /**
     * Choose, which Endereco to update.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco updateMany
   */
  export type EnderecoUpdateManyArgs = {
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
  }


  /**
   * Endereco upsert
   */
  export type EnderecoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * The filter to search for the Endereco to update in case it exists.
     */
    where: EnderecoWhereUniqueInput
    /**
     * In case the Endereco found by the `where` argument doesn't exist, create a new Endereco with this data.
     */
    create: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
    /**
     * In case the Endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
  }


  /**
   * Endereco delete
   */
  export type EnderecoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
    /**
     * Filter which Endereco to delete.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco deleteMany
   */
  export type EnderecoDeleteManyArgs = {
    /**
     * Filter which Enderecos to delete
     */
    where?: EnderecoWhereInput
  }


  /**
   * Endereco without action
   */
  export type EnderecoArgs = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    idPessoa: string | null
    email: string | null
    password: string | null
    refreshToken: string | null
    dataCadastro: Date | null
    dataAtualizado: Date | null
    ativo: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    idPessoa: string | null
    email: string | null
    password: string | null
    refreshToken: string | null
    dataCadastro: Date | null
    dataAtualizado: Date | null
    ativo: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    idPessoa: number
    email: number
    password: number
    refreshToken: number
    dataCadastro: number
    dataAtualizado: number
    ativo: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    idPessoa?: true
    email?: true
    password?: true
    refreshToken?: true
    dataCadastro?: true
    dataAtualizado?: true
    ativo?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    idPessoa?: true
    email?: true
    password?: true
    refreshToken?: true
    dataCadastro?: true
    dataAtualizado?: true
    ativo?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    idPessoa?: true
    email?: true
    password?: true
    refreshToken?: true
    dataCadastro?: true
    dataAtualizado?: true
    ativo?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    idPessoa: string
    email: string
    password: string
    refreshToken: string | null
    dataCadastro: Date
    dataAtualizado: Date | null
    ativo: boolean | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    idPessoa?: boolean
    email?: boolean
    password?: boolean
    refreshToken?: boolean
    dataCadastro?: boolean
    dataAtualizado?: boolean
    ativo?: boolean
    pessoa?: boolean | PessoaArgs
  }


  export type UserInclude = {
    pessoa?: boolean | PessoaArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pessoa' ? PessoaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pessoa' ? PessoaGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model UserEmpresa
   */


  export type AggregateUserEmpresa = {
    _count: UserEmpresaCountAggregateOutputType | null
    _min: UserEmpresaMinAggregateOutputType | null
    _max: UserEmpresaMaxAggregateOutputType | null
  }

  export type UserEmpresaMinAggregateOutputType = {
    id: string | null
    idPessoa: string | null
    idEmpresa: string | null
    pessoaId: string | null
  }

  export type UserEmpresaMaxAggregateOutputType = {
    id: string | null
    idPessoa: string | null
    idEmpresa: string | null
    pessoaId: string | null
  }

  export type UserEmpresaCountAggregateOutputType = {
    id: number
    idPessoa: number
    idEmpresa: number
    pessoaId: number
    _all: number
  }


  export type UserEmpresaMinAggregateInputType = {
    id?: true
    idPessoa?: true
    idEmpresa?: true
    pessoaId?: true
  }

  export type UserEmpresaMaxAggregateInputType = {
    id?: true
    idPessoa?: true
    idEmpresa?: true
    pessoaId?: true
  }

  export type UserEmpresaCountAggregateInputType = {
    id?: true
    idPessoa?: true
    idEmpresa?: true
    pessoaId?: true
    _all?: true
  }

  export type UserEmpresaAggregateArgs = {
    /**
     * Filter which UserEmpresa to aggregate.
     */
    where?: UserEmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmpresas to fetch.
     */
    orderBy?: Enumerable<UserEmpresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmpresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmpresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEmpresas
    **/
    _count?: true | UserEmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEmpresaMaxAggregateInputType
  }

  export type GetUserEmpresaAggregateType<T extends UserEmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEmpresa[P]>
      : GetScalarType<T[P], AggregateUserEmpresa[P]>
  }




  export type UserEmpresaGroupByArgs = {
    where?: UserEmpresaWhereInput
    orderBy?: Enumerable<UserEmpresaOrderByWithAggregationInput>
    by: UserEmpresaScalarFieldEnum[]
    having?: UserEmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEmpresaCountAggregateInputType | true
    _min?: UserEmpresaMinAggregateInputType
    _max?: UserEmpresaMaxAggregateInputType
  }


  export type UserEmpresaGroupByOutputType = {
    id: string
    idPessoa: string
    idEmpresa: string
    pessoaId: string | null
    _count: UserEmpresaCountAggregateOutputType | null
    _min: UserEmpresaMinAggregateOutputType | null
    _max: UserEmpresaMaxAggregateOutputType | null
  }

  type GetUserEmpresaGroupByPayload<T extends UserEmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserEmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], UserEmpresaGroupByOutputType[P]>
        }
      >
    >


  export type UserEmpresaSelect = {
    id?: boolean
    idPessoa?: boolean
    idEmpresa?: boolean
    pessoaId?: boolean
    Pessoa?: boolean | PessoaArgs
  }


  export type UserEmpresaInclude = {
    Pessoa?: boolean | PessoaArgs
  }

  export type UserEmpresaGetPayload<S extends boolean | null | undefined | UserEmpresaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserEmpresa :
    S extends undefined ? never :
    S extends { include: any } & (UserEmpresaArgs | UserEmpresaFindManyArgs)
    ? UserEmpresa  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Pessoa' ? PessoaGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (UserEmpresaArgs | UserEmpresaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Pessoa' ? PessoaGetPayload<S['select'][P]> | null :  P extends keyof UserEmpresa ? UserEmpresa[P] : never
  } 
      : UserEmpresa


  type UserEmpresaCountArgs = 
    Omit<UserEmpresaFindManyArgs, 'select' | 'include'> & {
      select?: UserEmpresaCountAggregateInputType | true
    }

  export interface UserEmpresaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserEmpresa that matches the filter.
     * @param {UserEmpresaFindUniqueArgs} args - Arguments to find a UserEmpresa
     * @example
     * // Get one UserEmpresa
     * const userEmpresa = await prisma.userEmpresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserEmpresaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserEmpresaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserEmpresa'> extends True ? Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>> : Prisma__UserEmpresaClient<UserEmpresaGetPayload<T> | null, null>

    /**
     * Find one UserEmpresa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserEmpresaFindUniqueOrThrowArgs} args - Arguments to find a UserEmpresa
     * @example
     * // Get one UserEmpresa
     * const userEmpresa = await prisma.userEmpresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserEmpresaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserEmpresaFindUniqueOrThrowArgs>
    ): Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>>

    /**
     * Find the first UserEmpresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaFindFirstArgs} args - Arguments to find a UserEmpresa
     * @example
     * // Get one UserEmpresa
     * const userEmpresa = await prisma.userEmpresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserEmpresaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserEmpresaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserEmpresa'> extends True ? Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>> : Prisma__UserEmpresaClient<UserEmpresaGetPayload<T> | null, null>

    /**
     * Find the first UserEmpresa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaFindFirstOrThrowArgs} args - Arguments to find a UserEmpresa
     * @example
     * // Get one UserEmpresa
     * const userEmpresa = await prisma.userEmpresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserEmpresaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserEmpresaFindFirstOrThrowArgs>
    ): Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>>

    /**
     * Find zero or more UserEmpresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEmpresas
     * const userEmpresas = await prisma.userEmpresa.findMany()
     * 
     * // Get first 10 UserEmpresas
     * const userEmpresas = await prisma.userEmpresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEmpresaWithIdOnly = await prisma.userEmpresa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserEmpresaFindManyArgs>(
      args?: SelectSubset<T, UserEmpresaFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserEmpresaGetPayload<T>>>

    /**
     * Create a UserEmpresa.
     * @param {UserEmpresaCreateArgs} args - Arguments to create a UserEmpresa.
     * @example
     * // Create one UserEmpresa
     * const UserEmpresa = await prisma.userEmpresa.create({
     *   data: {
     *     // ... data to create a UserEmpresa
     *   }
     * })
     * 
    **/
    create<T extends UserEmpresaCreateArgs>(
      args: SelectSubset<T, UserEmpresaCreateArgs>
    ): Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>>

    /**
     * Create many UserEmpresas.
     *     @param {UserEmpresaCreateManyArgs} args - Arguments to create many UserEmpresas.
     *     @example
     *     // Create many UserEmpresas
     *     const userEmpresa = await prisma.userEmpresa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserEmpresaCreateManyArgs>(
      args?: SelectSubset<T, UserEmpresaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserEmpresa.
     * @param {UserEmpresaDeleteArgs} args - Arguments to delete one UserEmpresa.
     * @example
     * // Delete one UserEmpresa
     * const UserEmpresa = await prisma.userEmpresa.delete({
     *   where: {
     *     // ... filter to delete one UserEmpresa
     *   }
     * })
     * 
    **/
    delete<T extends UserEmpresaDeleteArgs>(
      args: SelectSubset<T, UserEmpresaDeleteArgs>
    ): Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>>

    /**
     * Update one UserEmpresa.
     * @param {UserEmpresaUpdateArgs} args - Arguments to update one UserEmpresa.
     * @example
     * // Update one UserEmpresa
     * const userEmpresa = await prisma.userEmpresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserEmpresaUpdateArgs>(
      args: SelectSubset<T, UserEmpresaUpdateArgs>
    ): Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>>

    /**
     * Delete zero or more UserEmpresas.
     * @param {UserEmpresaDeleteManyArgs} args - Arguments to filter UserEmpresas to delete.
     * @example
     * // Delete a few UserEmpresas
     * const { count } = await prisma.userEmpresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserEmpresaDeleteManyArgs>(
      args?: SelectSubset<T, UserEmpresaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmpresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEmpresas
     * const userEmpresa = await prisma.userEmpresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserEmpresaUpdateManyArgs>(
      args: SelectSubset<T, UserEmpresaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserEmpresa.
     * @param {UserEmpresaUpsertArgs} args - Arguments to update or create a UserEmpresa.
     * @example
     * // Update or create a UserEmpresa
     * const userEmpresa = await prisma.userEmpresa.upsert({
     *   create: {
     *     // ... data to create a UserEmpresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEmpresa we want to update
     *   }
     * })
    **/
    upsert<T extends UserEmpresaUpsertArgs>(
      args: SelectSubset<T, UserEmpresaUpsertArgs>
    ): Prisma__UserEmpresaClient<UserEmpresaGetPayload<T>>

    /**
     * Count the number of UserEmpresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaCountArgs} args - Arguments to filter UserEmpresas to count.
     * @example
     * // Count the number of UserEmpresas
     * const count = await prisma.userEmpresa.count({
     *   where: {
     *     // ... the filter for the UserEmpresas we want to count
     *   }
     * })
    **/
    count<T extends UserEmpresaCountArgs>(
      args?: Subset<T, UserEmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEmpresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEmpresaAggregateArgs>(args: Subset<T, UserEmpresaAggregateArgs>): Prisma.PrismaPromise<GetUserEmpresaAggregateType<T>>

    /**
     * Group by UserEmpresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEmpresaGroupByArgs['orderBy'] }
        : { orderBy?: UserEmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEmpresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserEmpresaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserEmpresa base type for findUnique actions
   */
  export type UserEmpresaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * Filter, which UserEmpresa to fetch.
     */
    where: UserEmpresaWhereUniqueInput
  }

  /**
   * UserEmpresa findUnique
   */
  export interface UserEmpresaFindUniqueArgs extends UserEmpresaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserEmpresa findUniqueOrThrow
   */
  export type UserEmpresaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * Filter, which UserEmpresa to fetch.
     */
    where: UserEmpresaWhereUniqueInput
  }


  /**
   * UserEmpresa base type for findFirst actions
   */
  export type UserEmpresaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * Filter, which UserEmpresa to fetch.
     */
    where?: UserEmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmpresas to fetch.
     */
    orderBy?: Enumerable<UserEmpresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmpresas.
     */
    cursor?: UserEmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmpresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmpresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmpresas.
     */
    distinct?: Enumerable<UserEmpresaScalarFieldEnum>
  }

  /**
   * UserEmpresa findFirst
   */
  export interface UserEmpresaFindFirstArgs extends UserEmpresaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserEmpresa findFirstOrThrow
   */
  export type UserEmpresaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * Filter, which UserEmpresa to fetch.
     */
    where?: UserEmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmpresas to fetch.
     */
    orderBy?: Enumerable<UserEmpresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmpresas.
     */
    cursor?: UserEmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmpresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmpresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmpresas.
     */
    distinct?: Enumerable<UserEmpresaScalarFieldEnum>
  }


  /**
   * UserEmpresa findMany
   */
  export type UserEmpresaFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * Filter, which UserEmpresas to fetch.
     */
    where?: UserEmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmpresas to fetch.
     */
    orderBy?: Enumerable<UserEmpresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEmpresas.
     */
    cursor?: UserEmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmpresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmpresas.
     */
    skip?: number
    distinct?: Enumerable<UserEmpresaScalarFieldEnum>
  }


  /**
   * UserEmpresa create
   */
  export type UserEmpresaCreateArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * The data needed to create a UserEmpresa.
     */
    data: XOR<UserEmpresaCreateInput, UserEmpresaUncheckedCreateInput>
  }


  /**
   * UserEmpresa createMany
   */
  export type UserEmpresaCreateManyArgs = {
    /**
     * The data used to create many UserEmpresas.
     */
    data: Enumerable<UserEmpresaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserEmpresa update
   */
  export type UserEmpresaUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * The data needed to update a UserEmpresa.
     */
    data: XOR<UserEmpresaUpdateInput, UserEmpresaUncheckedUpdateInput>
    /**
     * Choose, which UserEmpresa to update.
     */
    where: UserEmpresaWhereUniqueInput
  }


  /**
   * UserEmpresa updateMany
   */
  export type UserEmpresaUpdateManyArgs = {
    /**
     * The data used to update UserEmpresas.
     */
    data: XOR<UserEmpresaUpdateManyMutationInput, UserEmpresaUncheckedUpdateManyInput>
    /**
     * Filter which UserEmpresas to update
     */
    where?: UserEmpresaWhereInput
  }


  /**
   * UserEmpresa upsert
   */
  export type UserEmpresaUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * The filter to search for the UserEmpresa to update in case it exists.
     */
    where: UserEmpresaWhereUniqueInput
    /**
     * In case the UserEmpresa found by the `where` argument doesn't exist, create a new UserEmpresa with this data.
     */
    create: XOR<UserEmpresaCreateInput, UserEmpresaUncheckedCreateInput>
    /**
     * In case the UserEmpresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEmpresaUpdateInput, UserEmpresaUncheckedUpdateInput>
  }


  /**
   * UserEmpresa delete
   */
  export type UserEmpresaDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
    /**
     * Filter which UserEmpresa to delete.
     */
    where: UserEmpresaWhereUniqueInput
  }


  /**
   * UserEmpresa deleteMany
   */
  export type UserEmpresaDeleteManyArgs = {
    /**
     * Filter which UserEmpresas to delete
     */
    where?: UserEmpresaWhereInput
  }


  /**
   * UserEmpresa without action
   */
  export type UserEmpresaArgs = {
    /**
     * Select specific fields to fetch from the UserEmpresa
     */
    select?: UserEmpresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEmpresaInclude | null
  }



  /**
   * Model Permissao
   */


  export type AggregatePermissao = {
    _count: PermissaoCountAggregateOutputType | null
    _min: PermissaoMinAggregateOutputType | null
    _max: PermissaoMaxAggregateOutputType | null
  }

  export type PermissaoMinAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
    listar: boolean | null
    cadastrar: boolean | null
    editar: boolean | null
    excluir: boolean | null
  }

  export type PermissaoMaxAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
    listar: boolean | null
    cadastrar: boolean | null
    editar: boolean | null
    excluir: boolean | null
  }

  export type PermissaoCountAggregateOutputType = {
    id: number
    idTipo: number
    idPessoa: number
    listar: number
    cadastrar: number
    editar: number
    excluir: number
    _all: number
  }


  export type PermissaoMinAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    listar?: true
    cadastrar?: true
    editar?: true
    excluir?: true
  }

  export type PermissaoMaxAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    listar?: true
    cadastrar?: true
    editar?: true
    excluir?: true
  }

  export type PermissaoCountAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    listar?: true
    cadastrar?: true
    editar?: true
    excluir?: true
    _all?: true
  }

  export type PermissaoAggregateArgs = {
    /**
     * Filter which Permissao to aggregate.
     */
    where?: PermissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissaos to fetch.
     */
    orderBy?: Enumerable<PermissaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissaos
    **/
    _count?: true | PermissaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissaoMaxAggregateInputType
  }

  export type GetPermissaoAggregateType<T extends PermissaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissao[P]>
      : GetScalarType<T[P], AggregatePermissao[P]>
  }




  export type PermissaoGroupByArgs = {
    where?: PermissaoWhereInput
    orderBy?: Enumerable<PermissaoOrderByWithAggregationInput>
    by: PermissaoScalarFieldEnum[]
    having?: PermissaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissaoCountAggregateInputType | true
    _min?: PermissaoMinAggregateInputType
    _max?: PermissaoMaxAggregateInputType
  }


  export type PermissaoGroupByOutputType = {
    id: string
    idTipo: string
    idPessoa: string
    listar: boolean | null
    cadastrar: boolean | null
    editar: boolean | null
    excluir: boolean | null
    _count: PermissaoCountAggregateOutputType | null
    _min: PermissaoMinAggregateOutputType | null
    _max: PermissaoMaxAggregateOutputType | null
  }

  type GetPermissaoGroupByPayload<T extends PermissaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PermissaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissaoGroupByOutputType[P]>
            : GetScalarType<T[P], PermissaoGroupByOutputType[P]>
        }
      >
    >


  export type PermissaoSelect = {
    id?: boolean
    idTipo?: boolean
    idPessoa?: boolean
    listar?: boolean
    cadastrar?: boolean
    editar?: boolean
    excluir?: boolean
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }


  export type PermissaoInclude = {
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }

  export type PermissaoGetPayload<S extends boolean | null | undefined | PermissaoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Permissao :
    S extends undefined ? never :
    S extends { include: any } & (PermissaoArgs | PermissaoFindManyArgs)
    ? Permissao  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tipo' ? TipoGetPayload<S['include'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PermissaoArgs | PermissaoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tipo' ? TipoGetPayload<S['select'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['select'][P]> :  P extends keyof Permissao ? Permissao[P] : never
  } 
      : Permissao


  type PermissaoCountArgs = 
    Omit<PermissaoFindManyArgs, 'select' | 'include'> & {
      select?: PermissaoCountAggregateInputType | true
    }

  export interface PermissaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Permissao that matches the filter.
     * @param {PermissaoFindUniqueArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermissaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permissao'> extends True ? Prisma__PermissaoClient<PermissaoGetPayload<T>> : Prisma__PermissaoClient<PermissaoGetPayload<T> | null, null>

    /**
     * Find one Permissao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PermissaoFindUniqueOrThrowArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermissaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PermissaoFindUniqueOrThrowArgs>
    ): Prisma__PermissaoClient<PermissaoGetPayload<T>>

    /**
     * Find the first Permissao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoFindFirstArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermissaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permissao'> extends True ? Prisma__PermissaoClient<PermissaoGetPayload<T>> : Prisma__PermissaoClient<PermissaoGetPayload<T> | null, null>

    /**
     * Find the first Permissao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoFindFirstOrThrowArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermissaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermissaoFindFirstOrThrowArgs>
    ): Prisma__PermissaoClient<PermissaoGetPayload<T>>

    /**
     * Find zero or more Permissaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissaos
     * const permissaos = await prisma.permissao.findMany()
     * 
     * // Get first 10 Permissaos
     * const permissaos = await prisma.permissao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissaoWithIdOnly = await prisma.permissao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissaoFindManyArgs>(
      args?: SelectSubset<T, PermissaoFindManyArgs>
    ): Prisma.PrismaPromise<Array<PermissaoGetPayload<T>>>

    /**
     * Create a Permissao.
     * @param {PermissaoCreateArgs} args - Arguments to create a Permissao.
     * @example
     * // Create one Permissao
     * const Permissao = await prisma.permissao.create({
     *   data: {
     *     // ... data to create a Permissao
     *   }
     * })
     * 
    **/
    create<T extends PermissaoCreateArgs>(
      args: SelectSubset<T, PermissaoCreateArgs>
    ): Prisma__PermissaoClient<PermissaoGetPayload<T>>

    /**
     * Create many Permissaos.
     *     @param {PermissaoCreateManyArgs} args - Arguments to create many Permissaos.
     *     @example
     *     // Create many Permissaos
     *     const permissao = await prisma.permissao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissaoCreateManyArgs>(
      args?: SelectSubset<T, PermissaoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissao.
     * @param {PermissaoDeleteArgs} args - Arguments to delete one Permissao.
     * @example
     * // Delete one Permissao
     * const Permissao = await prisma.permissao.delete({
     *   where: {
     *     // ... filter to delete one Permissao
     *   }
     * })
     * 
    **/
    delete<T extends PermissaoDeleteArgs>(
      args: SelectSubset<T, PermissaoDeleteArgs>
    ): Prisma__PermissaoClient<PermissaoGetPayload<T>>

    /**
     * Update one Permissao.
     * @param {PermissaoUpdateArgs} args - Arguments to update one Permissao.
     * @example
     * // Update one Permissao
     * const permissao = await prisma.permissao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissaoUpdateArgs>(
      args: SelectSubset<T, PermissaoUpdateArgs>
    ): Prisma__PermissaoClient<PermissaoGetPayload<T>>

    /**
     * Delete zero or more Permissaos.
     * @param {PermissaoDeleteManyArgs} args - Arguments to filter Permissaos to delete.
     * @example
     * // Delete a few Permissaos
     * const { count } = await prisma.permissao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissaoDeleteManyArgs>(
      args?: SelectSubset<T, PermissaoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissaos
     * const permissao = await prisma.permissao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissaoUpdateManyArgs>(
      args: SelectSubset<T, PermissaoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissao.
     * @param {PermissaoUpsertArgs} args - Arguments to update or create a Permissao.
     * @example
     * // Update or create a Permissao
     * const permissao = await prisma.permissao.upsert({
     *   create: {
     *     // ... data to create a Permissao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissao we want to update
     *   }
     * })
    **/
    upsert<T extends PermissaoUpsertArgs>(
      args: SelectSubset<T, PermissaoUpsertArgs>
    ): Prisma__PermissaoClient<PermissaoGetPayload<T>>

    /**
     * Count the number of Permissaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoCountArgs} args - Arguments to filter Permissaos to count.
     * @example
     * // Count the number of Permissaos
     * const count = await prisma.permissao.count({
     *   where: {
     *     // ... the filter for the Permissaos we want to count
     *   }
     * })
    **/
    count<T extends PermissaoCountArgs>(
      args?: Subset<T, PermissaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissaoAggregateArgs>(args: Subset<T, PermissaoAggregateArgs>): Prisma.PrismaPromise<GetPermissaoAggregateType<T>>

    /**
     * Group by Permissao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissaoGroupByArgs['orderBy'] }
        : { orderBy?: PermissaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermissaoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tipo<T extends TipoArgs= {}>(args?: Subset<T, TipoArgs>): Prisma__TipoClient<TipoGetPayload<T> | Null>;

    pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Permissao base type for findUnique actions
   */
  export type PermissaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * Filter, which Permissao to fetch.
     */
    where: PermissaoWhereUniqueInput
  }

  /**
   * Permissao findUnique
   */
  export interface PermissaoFindUniqueArgs extends PermissaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permissao findUniqueOrThrow
   */
  export type PermissaoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * Filter, which Permissao to fetch.
     */
    where: PermissaoWhereUniqueInput
  }


  /**
   * Permissao base type for findFirst actions
   */
  export type PermissaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * Filter, which Permissao to fetch.
     */
    where?: PermissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissaos to fetch.
     */
    orderBy?: Enumerable<PermissaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissaos.
     */
    cursor?: PermissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissaos.
     */
    distinct?: Enumerable<PermissaoScalarFieldEnum>
  }

  /**
   * Permissao findFirst
   */
  export interface PermissaoFindFirstArgs extends PermissaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permissao findFirstOrThrow
   */
  export type PermissaoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * Filter, which Permissao to fetch.
     */
    where?: PermissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissaos to fetch.
     */
    orderBy?: Enumerable<PermissaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissaos.
     */
    cursor?: PermissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissaos.
     */
    distinct?: Enumerable<PermissaoScalarFieldEnum>
  }


  /**
   * Permissao findMany
   */
  export type PermissaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * Filter, which Permissaos to fetch.
     */
    where?: PermissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissaos to fetch.
     */
    orderBy?: Enumerable<PermissaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissaos.
     */
    cursor?: PermissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissaos.
     */
    skip?: number
    distinct?: Enumerable<PermissaoScalarFieldEnum>
  }


  /**
   * Permissao create
   */
  export type PermissaoCreateArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * The data needed to create a Permissao.
     */
    data: XOR<PermissaoCreateInput, PermissaoUncheckedCreateInput>
  }


  /**
   * Permissao createMany
   */
  export type PermissaoCreateManyArgs = {
    /**
     * The data used to create many Permissaos.
     */
    data: Enumerable<PermissaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Permissao update
   */
  export type PermissaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * The data needed to update a Permissao.
     */
    data: XOR<PermissaoUpdateInput, PermissaoUncheckedUpdateInput>
    /**
     * Choose, which Permissao to update.
     */
    where: PermissaoWhereUniqueInput
  }


  /**
   * Permissao updateMany
   */
  export type PermissaoUpdateManyArgs = {
    /**
     * The data used to update Permissaos.
     */
    data: XOR<PermissaoUpdateManyMutationInput, PermissaoUncheckedUpdateManyInput>
    /**
     * Filter which Permissaos to update
     */
    where?: PermissaoWhereInput
  }


  /**
   * Permissao upsert
   */
  export type PermissaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * The filter to search for the Permissao to update in case it exists.
     */
    where: PermissaoWhereUniqueInput
    /**
     * In case the Permissao found by the `where` argument doesn't exist, create a new Permissao with this data.
     */
    create: XOR<PermissaoCreateInput, PermissaoUncheckedCreateInput>
    /**
     * In case the Permissao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissaoUpdateInput, PermissaoUncheckedUpdateInput>
  }


  /**
   * Permissao delete
   */
  export type PermissaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
    /**
     * Filter which Permissao to delete.
     */
    where: PermissaoWhereUniqueInput
  }


  /**
   * Permissao deleteMany
   */
  export type PermissaoDeleteManyArgs = {
    /**
     * Filter which Permissaos to delete
     */
    where?: PermissaoWhereInput
  }


  /**
   * Permissao without action
   */
  export type PermissaoArgs = {
    /**
     * Select specific fields to fetch from the Permissao
     */
    select?: PermissaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissaoInclude | null
  }



  /**
   * Model Contato
   */


  export type AggregateContato = {
    _count: ContatoCountAggregateOutputType | null
    _min: ContatoMinAggregateOutputType | null
    _max: ContatoMaxAggregateOutputType | null
  }

  export type ContatoMinAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
    descricao: string | null
    ativo: boolean | null
  }

  export type ContatoMaxAggregateOutputType = {
    id: string | null
    idTipo: string | null
    idPessoa: string | null
    descricao: string | null
    ativo: boolean | null
  }

  export type ContatoCountAggregateOutputType = {
    id: number
    idTipo: number
    idPessoa: number
    descricao: number
    ativo: number
    _all: number
  }


  export type ContatoMinAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    descricao?: true
    ativo?: true
  }

  export type ContatoMaxAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    descricao?: true
    ativo?: true
  }

  export type ContatoCountAggregateInputType = {
    id?: true
    idTipo?: true
    idPessoa?: true
    descricao?: true
    ativo?: true
    _all?: true
  }

  export type ContatoAggregateArgs = {
    /**
     * Filter which Contato to aggregate.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: Enumerable<ContatoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contatoes
    **/
    _count?: true | ContatoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContatoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContatoMaxAggregateInputType
  }

  export type GetContatoAggregateType<T extends ContatoAggregateArgs> = {
        [P in keyof T & keyof AggregateContato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContato[P]>
      : GetScalarType<T[P], AggregateContato[P]>
  }




  export type ContatoGroupByArgs = {
    where?: ContatoWhereInput
    orderBy?: Enumerable<ContatoOrderByWithAggregationInput>
    by: ContatoScalarFieldEnum[]
    having?: ContatoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContatoCountAggregateInputType | true
    _min?: ContatoMinAggregateInputType
    _max?: ContatoMaxAggregateInputType
  }


  export type ContatoGroupByOutputType = {
    id: string
    idTipo: string
    idPessoa: string
    descricao: string
    ativo: boolean | null
    _count: ContatoCountAggregateOutputType | null
    _min: ContatoMinAggregateOutputType | null
    _max: ContatoMaxAggregateOutputType | null
  }

  type GetContatoGroupByPayload<T extends ContatoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ContatoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContatoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContatoGroupByOutputType[P]>
            : GetScalarType<T[P], ContatoGroupByOutputType[P]>
        }
      >
    >


  export type ContatoSelect = {
    id?: boolean
    idTipo?: boolean
    idPessoa?: boolean
    descricao?: boolean
    ativo?: boolean
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }


  export type ContatoInclude = {
    tipo?: boolean | TipoArgs
    pessoa?: boolean | PessoaArgs
  }

  export type ContatoGetPayload<S extends boolean | null | undefined | ContatoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Contato :
    S extends undefined ? never :
    S extends { include: any } & (ContatoArgs | ContatoFindManyArgs)
    ? Contato  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tipo' ? TipoGetPayload<S['include'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ContatoArgs | ContatoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tipo' ? TipoGetPayload<S['select'][P]> :
        P extends 'pessoa' ? PessoaGetPayload<S['select'][P]> :  P extends keyof Contato ? Contato[P] : never
  } 
      : Contato


  type ContatoCountArgs = 
    Omit<ContatoFindManyArgs, 'select' | 'include'> & {
      select?: ContatoCountAggregateInputType | true
    }

  export interface ContatoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Contato that matches the filter.
     * @param {ContatoFindUniqueArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContatoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContatoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Contato'> extends True ? Prisma__ContatoClient<ContatoGetPayload<T>> : Prisma__ContatoClient<ContatoGetPayload<T> | null, null>

    /**
     * Find one Contato that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContatoFindUniqueOrThrowArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContatoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ContatoFindUniqueOrThrowArgs>
    ): Prisma__ContatoClient<ContatoGetPayload<T>>

    /**
     * Find the first Contato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoFindFirstArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContatoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContatoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Contato'> extends True ? Prisma__ContatoClient<ContatoGetPayload<T>> : Prisma__ContatoClient<ContatoGetPayload<T> | null, null>

    /**
     * Find the first Contato that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoFindFirstOrThrowArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContatoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ContatoFindFirstOrThrowArgs>
    ): Prisma__ContatoClient<ContatoGetPayload<T>>

    /**
     * Find zero or more Contatoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contatoes
     * const contatoes = await prisma.contato.findMany()
     * 
     * // Get first 10 Contatoes
     * const contatoes = await prisma.contato.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contatoWithIdOnly = await prisma.contato.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContatoFindManyArgs>(
      args?: SelectSubset<T, ContatoFindManyArgs>
    ): Prisma.PrismaPromise<Array<ContatoGetPayload<T>>>

    /**
     * Create a Contato.
     * @param {ContatoCreateArgs} args - Arguments to create a Contato.
     * @example
     * // Create one Contato
     * const Contato = await prisma.contato.create({
     *   data: {
     *     // ... data to create a Contato
     *   }
     * })
     * 
    **/
    create<T extends ContatoCreateArgs>(
      args: SelectSubset<T, ContatoCreateArgs>
    ): Prisma__ContatoClient<ContatoGetPayload<T>>

    /**
     * Create many Contatoes.
     *     @param {ContatoCreateManyArgs} args - Arguments to create many Contatoes.
     *     @example
     *     // Create many Contatoes
     *     const contato = await prisma.contato.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContatoCreateManyArgs>(
      args?: SelectSubset<T, ContatoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contato.
     * @param {ContatoDeleteArgs} args - Arguments to delete one Contato.
     * @example
     * // Delete one Contato
     * const Contato = await prisma.contato.delete({
     *   where: {
     *     // ... filter to delete one Contato
     *   }
     * })
     * 
    **/
    delete<T extends ContatoDeleteArgs>(
      args: SelectSubset<T, ContatoDeleteArgs>
    ): Prisma__ContatoClient<ContatoGetPayload<T>>

    /**
     * Update one Contato.
     * @param {ContatoUpdateArgs} args - Arguments to update one Contato.
     * @example
     * // Update one Contato
     * const contato = await prisma.contato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContatoUpdateArgs>(
      args: SelectSubset<T, ContatoUpdateArgs>
    ): Prisma__ContatoClient<ContatoGetPayload<T>>

    /**
     * Delete zero or more Contatoes.
     * @param {ContatoDeleteManyArgs} args - Arguments to filter Contatoes to delete.
     * @example
     * // Delete a few Contatoes
     * const { count } = await prisma.contato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContatoDeleteManyArgs>(
      args?: SelectSubset<T, ContatoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contatoes
     * const contato = await prisma.contato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContatoUpdateManyArgs>(
      args: SelectSubset<T, ContatoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contato.
     * @param {ContatoUpsertArgs} args - Arguments to update or create a Contato.
     * @example
     * // Update or create a Contato
     * const contato = await prisma.contato.upsert({
     *   create: {
     *     // ... data to create a Contato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contato we want to update
     *   }
     * })
    **/
    upsert<T extends ContatoUpsertArgs>(
      args: SelectSubset<T, ContatoUpsertArgs>
    ): Prisma__ContatoClient<ContatoGetPayload<T>>

    /**
     * Count the number of Contatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoCountArgs} args - Arguments to filter Contatoes to count.
     * @example
     * // Count the number of Contatoes
     * const count = await prisma.contato.count({
     *   where: {
     *     // ... the filter for the Contatoes we want to count
     *   }
     * })
    **/
    count<T extends ContatoCountArgs>(
      args?: Subset<T, ContatoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContatoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContatoAggregateArgs>(args: Subset<T, ContatoAggregateArgs>): Prisma.PrismaPromise<GetContatoAggregateType<T>>

    /**
     * Group by Contato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContatoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContatoGroupByArgs['orderBy'] }
        : { orderBy?: ContatoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContatoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContatoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Contato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContatoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tipo<T extends TipoArgs= {}>(args?: Subset<T, TipoArgs>): Prisma__TipoClient<TipoGetPayload<T> | Null>;

    pessoa<T extends PessoaArgs= {}>(args?: Subset<T, PessoaArgs>): Prisma__PessoaClient<PessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Contato base type for findUnique actions
   */
  export type ContatoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * Filter, which Contato to fetch.
     */
    where: ContatoWhereUniqueInput
  }

  /**
   * Contato findUnique
   */
  export interface ContatoFindUniqueArgs extends ContatoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Contato findUniqueOrThrow
   */
  export type ContatoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * Filter, which Contato to fetch.
     */
    where: ContatoWhereUniqueInput
  }


  /**
   * Contato base type for findFirst actions
   */
  export type ContatoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * Filter, which Contato to fetch.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: Enumerable<ContatoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contatoes.
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contatoes.
     */
    distinct?: Enumerable<ContatoScalarFieldEnum>
  }

  /**
   * Contato findFirst
   */
  export interface ContatoFindFirstArgs extends ContatoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Contato findFirstOrThrow
   */
  export type ContatoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * Filter, which Contato to fetch.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: Enumerable<ContatoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contatoes.
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contatoes.
     */
    distinct?: Enumerable<ContatoScalarFieldEnum>
  }


  /**
   * Contato findMany
   */
  export type ContatoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * Filter, which Contatoes to fetch.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: Enumerable<ContatoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contatoes.
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    distinct?: Enumerable<ContatoScalarFieldEnum>
  }


  /**
   * Contato create
   */
  export type ContatoCreateArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * The data needed to create a Contato.
     */
    data: XOR<ContatoCreateInput, ContatoUncheckedCreateInput>
  }


  /**
   * Contato createMany
   */
  export type ContatoCreateManyArgs = {
    /**
     * The data used to create many Contatoes.
     */
    data: Enumerable<ContatoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Contato update
   */
  export type ContatoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * The data needed to update a Contato.
     */
    data: XOR<ContatoUpdateInput, ContatoUncheckedUpdateInput>
    /**
     * Choose, which Contato to update.
     */
    where: ContatoWhereUniqueInput
  }


  /**
   * Contato updateMany
   */
  export type ContatoUpdateManyArgs = {
    /**
     * The data used to update Contatoes.
     */
    data: XOR<ContatoUpdateManyMutationInput, ContatoUncheckedUpdateManyInput>
    /**
     * Filter which Contatoes to update
     */
    where?: ContatoWhereInput
  }


  /**
   * Contato upsert
   */
  export type ContatoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * The filter to search for the Contato to update in case it exists.
     */
    where: ContatoWhereUniqueInput
    /**
     * In case the Contato found by the `where` argument doesn't exist, create a new Contato with this data.
     */
    create: XOR<ContatoCreateInput, ContatoUncheckedCreateInput>
    /**
     * In case the Contato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContatoUpdateInput, ContatoUncheckedUpdateInput>
  }


  /**
   * Contato delete
   */
  export type ContatoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
    /**
     * Filter which Contato to delete.
     */
    where: ContatoWhereUniqueInput
  }


  /**
   * Contato deleteMany
   */
  export type ContatoDeleteManyArgs = {
    /**
     * Filter which Contatoes to delete
     */
    where?: ContatoWhereInput
  }


  /**
   * Contato without action
   */
  export type ContatoArgs = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContatoInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ContatoScalarFieldEnum: {
    id: 'id',
    idTipo: 'idTipo',
    idPessoa: 'idPessoa',
    descricao: 'descricao',
    ativo: 'ativo'
  };

  export type ContatoScalarFieldEnum = (typeof ContatoScalarFieldEnum)[keyof typeof ContatoScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    id: 'id',
    idTipo: 'idTipo',
    idPessoa: 'idPessoa',
    cep: 'cep',
    local: 'local',
    numero: 'numero',
    bairro: 'bairro',
    complemento: 'complemento',
    cidade: 'cidade',
    estado: 'estado',
    ativo: 'ativo',
    principal: 'principal'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const PermissaoScalarFieldEnum: {
    id: 'id',
    idTipo: 'idTipo',
    idPessoa: 'idPessoa',
    listar: 'listar',
    cadastrar: 'cadastrar',
    editar: 'editar',
    excluir: 'excluir'
  };

  export type PermissaoScalarFieldEnum = (typeof PermissaoScalarFieldEnum)[keyof typeof PermissaoScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    documento: 'documento',
    razaoSocial: 'razaoSocial',
    nomeFantasia: 'nomeFantasia',
    inscricaoMunicipal: 'inscricaoMunicipal',
    inscricaoEstadual: 'inscricaoEstadual',
    nascimento: 'nascimento',
    dataCadastro: 'dataCadastro',
    dataAtualizado: 'dataAtualizado',
    ativo: 'ativo',
    isAdmin: 'isAdmin',
    tipoId: 'tipoId',
    empresaId: 'empresaId'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const PessoaTipoScalarFieldEnum: {
    id: 'id',
    idTipo: 'idTipo',
    idPessoa: 'idPessoa'
  };

  export type PessoaTipoScalarFieldEnum = (typeof PessoaTipoScalarFieldEnum)[keyof typeof PessoaTipoScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    tipoId: 'tipoId',
    ativo: 'ativo'
  };

  export type TipoScalarFieldEnum = (typeof TipoScalarFieldEnum)[keyof typeof TipoScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserEmpresaScalarFieldEnum: {
    id: 'id',
    idPessoa: 'idPessoa',
    idEmpresa: 'idEmpresa',
    pessoaId: 'pessoaId'
  };

  export type UserEmpresaScalarFieldEnum = (typeof UserEmpresaScalarFieldEnum)[keyof typeof UserEmpresaScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    idPessoa: 'idPessoa',
    email: 'email',
    password: 'password',
    refreshToken: 'refreshToken',
    dataCadastro: 'dataCadastro',
    dataAtualizado: 'dataAtualizado',
    ativo: 'ativo'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type TipoWhereInput = {
    AND?: Enumerable<TipoWhereInput>
    OR?: Enumerable<TipoWhereInput>
    NOT?: Enumerable<TipoWhereInput>
    id?: StringFilter | string
    nome?: StringFilter | string
    tipoId?: StringNullableFilter | string | null
    ativo?: BoolFilter | boolean
    Tipo?: XOR<TipoRelationFilter, TipoWhereInput> | null
    Pessoa?: PessoaListRelationFilter
    Endereco?: EnderecoListRelationFilter
    Permissao?: PermissaoListRelationFilter
    Contato?: ContatoListRelationFilter
    PessoaTipo?: PessoaTipoListRelationFilter
    Tipos?: TipoListRelationFilter
  }

  export type TipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    tipoId?: SortOrder
    ativo?: SortOrder
    Tipo?: TipoOrderByWithRelationInput
    Pessoa?: PessoaOrderByRelationAggregateInput
    Endereco?: EnderecoOrderByRelationAggregateInput
    Permissao?: PermissaoOrderByRelationAggregateInput
    Contato?: ContatoOrderByRelationAggregateInput
    PessoaTipo?: PessoaTipoOrderByRelationAggregateInput
    Tipos?: TipoOrderByRelationAggregateInput
  }

  export type TipoWhereUniqueInput = {
    id?: string
  }

  export type TipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    tipoId?: SortOrder
    ativo?: SortOrder
    _count?: TipoCountOrderByAggregateInput
    _max?: TipoMaxOrderByAggregateInput
    _min?: TipoMinOrderByAggregateInput
  }

  export type TipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nome?: StringWithAggregatesFilter | string
    tipoId?: StringNullableWithAggregatesFilter | string | null
    ativo?: BoolWithAggregatesFilter | boolean
  }

  export type PessoaWhereInput = {
    AND?: Enumerable<PessoaWhereInput>
    OR?: Enumerable<PessoaWhereInput>
    NOT?: Enumerable<PessoaWhereInput>
    id?: StringFilter | string
    nome?: StringFilter | string
    documento?: StringNullableFilter | string | null
    razaoSocial?: StringNullableFilter | string | null
    nomeFantasia?: StringNullableFilter | string | null
    inscricaoMunicipal?: StringNullableFilter | string | null
    inscricaoEstadual?: StringNullableFilter | string | null
    nascimento?: DateTimeNullableFilter | Date | string | null
    dataCadastro?: DateTimeFilter | Date | string
    dataAtualizado?: DateTimeNullableFilter | Date | string | null
    ativo?: BoolNullableFilter | boolean | null
    isAdmin?: BoolNullableFilter | boolean | null
    tipoId?: StringNullableFilter | string | null
    empresaId?: StringNullableFilter | string | null
    Endereco?: EnderecoListRelationFilter
    User?: UserListRelationFilter
    Permissao?: PermissaoListRelationFilter
    Contato?: ContatoListRelationFilter
    Tipo?: XOR<TipoRelationFilter, TipoWhereInput> | null
    PessoaTipo?: PessoaTipoListRelationFilter
    empresa?: XOR<PessoaRelationFilter, PessoaWhereInput> | null
    Empresa?: PessoaListRelationFilter
    UserEmpresa?: UserEmpresaListRelationFilter
  }

  export type PessoaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    inscricaoMunicipal?: SortOrder
    inscricaoEstadual?: SortOrder
    nascimento?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    isAdmin?: SortOrder
    tipoId?: SortOrder
    empresaId?: SortOrder
    Endereco?: EnderecoOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    Permissao?: PermissaoOrderByRelationAggregateInput
    Contato?: ContatoOrderByRelationAggregateInput
    Tipo?: TipoOrderByWithRelationInput
    PessoaTipo?: PessoaTipoOrderByRelationAggregateInput
    empresa?: PessoaOrderByWithRelationInput
    Empresa?: PessoaOrderByRelationAggregateInput
    UserEmpresa?: UserEmpresaOrderByRelationAggregateInput
  }

  export type PessoaWhereUniqueInput = {
    id?: string
  }

  export type PessoaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    inscricaoMunicipal?: SortOrder
    inscricaoEstadual?: SortOrder
    nascimento?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    isAdmin?: SortOrder
    tipoId?: SortOrder
    empresaId?: SortOrder
    _count?: PessoaCountOrderByAggregateInput
    _max?: PessoaMaxOrderByAggregateInput
    _min?: PessoaMinOrderByAggregateInput
  }

  export type PessoaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PessoaScalarWhereWithAggregatesInput>
    OR?: Enumerable<PessoaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PessoaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nome?: StringWithAggregatesFilter | string
    documento?: StringNullableWithAggregatesFilter | string | null
    razaoSocial?: StringNullableWithAggregatesFilter | string | null
    nomeFantasia?: StringNullableWithAggregatesFilter | string | null
    inscricaoMunicipal?: StringNullableWithAggregatesFilter | string | null
    inscricaoEstadual?: StringNullableWithAggregatesFilter | string | null
    nascimento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dataCadastro?: DateTimeWithAggregatesFilter | Date | string
    dataAtualizado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ativo?: BoolNullableWithAggregatesFilter | boolean | null
    isAdmin?: BoolNullableWithAggregatesFilter | boolean | null
    tipoId?: StringNullableWithAggregatesFilter | string | null
    empresaId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PessoaTipoWhereInput = {
    AND?: Enumerable<PessoaTipoWhereInput>
    OR?: Enumerable<PessoaTipoWhereInput>
    NOT?: Enumerable<PessoaTipoWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    tipo?: XOR<TipoRelationFilter, TipoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput>
  }

  export type PessoaTipoOrderByWithRelationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    tipo?: TipoOrderByWithRelationInput
    pessoa?: PessoaOrderByWithRelationInput
  }

  export type PessoaTipoWhereUniqueInput = {
    id?: string
  }

  export type PessoaTipoOrderByWithAggregationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    _count?: PessoaTipoCountOrderByAggregateInput
    _max?: PessoaTipoMaxOrderByAggregateInput
    _min?: PessoaTipoMinOrderByAggregateInput
  }

  export type PessoaTipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PessoaTipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PessoaTipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PessoaTipoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    idTipo?: StringWithAggregatesFilter | string
    idPessoa?: StringWithAggregatesFilter | string
  }

  export type EnderecoWhereInput = {
    AND?: Enumerable<EnderecoWhereInput>
    OR?: Enumerable<EnderecoWhereInput>
    NOT?: Enumerable<EnderecoWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    cep?: StringFilter | string
    local?: StringFilter | string
    numero?: StringFilter | string
    bairro?: StringFilter | string
    complemento?: StringNullableFilter | string | null
    cidade?: StringFilter | string
    estado?: StringFilter | string
    ativo?: BoolNullableFilter | boolean | null
    principal?: BoolNullableFilter | boolean | null
    tipo?: XOR<TipoRelationFilter, TipoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput>
  }

  export type EnderecoOrderByWithRelationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    cep?: SortOrder
    local?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    complemento?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    principal?: SortOrder
    tipo?: TipoOrderByWithRelationInput
    pessoa?: PessoaOrderByWithRelationInput
  }

  export type EnderecoWhereUniqueInput = {
    id?: string
  }

  export type EnderecoOrderByWithAggregationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    cep?: SortOrder
    local?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    complemento?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    principal?: SortOrder
    _count?: EnderecoCountOrderByAggregateInput
    _max?: EnderecoMaxOrderByAggregateInput
    _min?: EnderecoMinOrderByAggregateInput
  }

  export type EnderecoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EnderecoScalarWhereWithAggregatesInput>
    OR?: Enumerable<EnderecoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EnderecoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    idTipo?: StringWithAggregatesFilter | string
    idPessoa?: StringWithAggregatesFilter | string
    cep?: StringWithAggregatesFilter | string
    local?: StringWithAggregatesFilter | string
    numero?: StringWithAggregatesFilter | string
    bairro?: StringWithAggregatesFilter | string
    complemento?: StringNullableWithAggregatesFilter | string | null
    cidade?: StringWithAggregatesFilter | string
    estado?: StringWithAggregatesFilter | string
    ativo?: BoolNullableWithAggregatesFilter | boolean | null
    principal?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    idPessoa?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    dataCadastro?: DateTimeFilter | Date | string
    dataAtualizado?: DateTimeNullableFilter | Date | string | null
    ativo?: BoolNullableFilter | boolean | null
    pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    pessoa?: PessoaOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    idPessoa?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    dataCadastro?: DateTimeWithAggregatesFilter | Date | string
    dataAtualizado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ativo?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type UserEmpresaWhereInput = {
    AND?: Enumerable<UserEmpresaWhereInput>
    OR?: Enumerable<UserEmpresaWhereInput>
    NOT?: Enumerable<UserEmpresaWhereInput>
    id?: StringFilter | string
    idPessoa?: StringFilter | string
    idEmpresa?: StringFilter | string
    pessoaId?: StringNullableFilter | string | null
    Pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput> | null
  }

  export type UserEmpresaOrderByWithRelationInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    idEmpresa?: SortOrder
    pessoaId?: SortOrder
    Pessoa?: PessoaOrderByWithRelationInput
  }

  export type UserEmpresaWhereUniqueInput = {
    id?: string
  }

  export type UserEmpresaOrderByWithAggregationInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    idEmpresa?: SortOrder
    pessoaId?: SortOrder
    _count?: UserEmpresaCountOrderByAggregateInput
    _max?: UserEmpresaMaxOrderByAggregateInput
    _min?: UserEmpresaMinOrderByAggregateInput
  }

  export type UserEmpresaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserEmpresaScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserEmpresaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserEmpresaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    idPessoa?: StringWithAggregatesFilter | string
    idEmpresa?: StringWithAggregatesFilter | string
    pessoaId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PermissaoWhereInput = {
    AND?: Enumerable<PermissaoWhereInput>
    OR?: Enumerable<PermissaoWhereInput>
    NOT?: Enumerable<PermissaoWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    listar?: BoolNullableFilter | boolean | null
    cadastrar?: BoolNullableFilter | boolean | null
    editar?: BoolNullableFilter | boolean | null
    excluir?: BoolNullableFilter | boolean | null
    tipo?: XOR<TipoRelationFilter, TipoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput>
  }

  export type PermissaoOrderByWithRelationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    listar?: SortOrder
    cadastrar?: SortOrder
    editar?: SortOrder
    excluir?: SortOrder
    tipo?: TipoOrderByWithRelationInput
    pessoa?: PessoaOrderByWithRelationInput
  }

  export type PermissaoWhereUniqueInput = {
    id?: string
  }

  export type PermissaoOrderByWithAggregationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    listar?: SortOrder
    cadastrar?: SortOrder
    editar?: SortOrder
    excluir?: SortOrder
    _count?: PermissaoCountOrderByAggregateInput
    _max?: PermissaoMaxOrderByAggregateInput
    _min?: PermissaoMinOrderByAggregateInput
  }

  export type PermissaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermissaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermissaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermissaoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    idTipo?: StringWithAggregatesFilter | string
    idPessoa?: StringWithAggregatesFilter | string
    listar?: BoolNullableWithAggregatesFilter | boolean | null
    cadastrar?: BoolNullableWithAggregatesFilter | boolean | null
    editar?: BoolNullableWithAggregatesFilter | boolean | null
    excluir?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ContatoWhereInput = {
    AND?: Enumerable<ContatoWhereInput>
    OR?: Enumerable<ContatoWhereInput>
    NOT?: Enumerable<ContatoWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    descricao?: StringFilter | string
    ativo?: BoolNullableFilter | boolean | null
    tipo?: XOR<TipoRelationFilter, TipoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, PessoaWhereInput>
  }

  export type ContatoOrderByWithRelationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    tipo?: TipoOrderByWithRelationInput
    pessoa?: PessoaOrderByWithRelationInput
  }

  export type ContatoWhereUniqueInput = {
    id?: string
  }

  export type ContatoOrderByWithAggregationInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    _count?: ContatoCountOrderByAggregateInput
    _max?: ContatoMaxOrderByAggregateInput
    _min?: ContatoMinOrderByAggregateInput
  }

  export type ContatoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContatoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContatoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContatoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    idTipo?: StringWithAggregatesFilter | string
    idPessoa?: StringWithAggregatesFilter | string
    descricao?: StringWithAggregatesFilter | string
    ativo?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type TipoCreateInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type TipoCreateManyInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
  }

  export type TipoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TipoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PessoaCreateInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaCreateManyInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
  }

  export type PessoaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PessoaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PessoaTipoCreateInput = {
    id?: string
    tipo: TipoCreateNestedOneWithoutPessoaTipoInput
    pessoa: PessoaCreateNestedOneWithoutPessoaTipoInput
  }

  export type PessoaTipoUncheckedCreateInput = {
    id?: string
    idTipo: string
    idPessoa: string
  }

  export type PessoaTipoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: TipoUpdateOneRequiredWithoutPessoaTipoNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutPessoaTipoNestedInput
  }

  export type PessoaTipoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaTipoCreateManyInput = {
    id?: string
    idTipo: string
    idPessoa: string
  }

  export type PessoaTipoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaTipoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoCreateInput = {
    id?: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
    tipo: TipoCreateNestedOneWithoutEnderecoInput
    pessoa: PessoaCreateNestedOneWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateInput = {
    id?: string
    idTipo: string
    idPessoa: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
  }

  export type EnderecoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo?: TipoUpdateOneRequiredWithoutEnderecoNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EnderecoCreateManyInput = {
    id?: string
    idTipo: string
    idPessoa: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
  }

  export type EnderecoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EnderecoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    refreshToken?: string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    pessoa: PessoaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    idPessoa: string
    email: string
    password: string
    refreshToken?: string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pessoa?: PessoaUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserCreateManyInput = {
    id?: string
    idPessoa: string
    email: string
    password: string
    refreshToken?: string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserEmpresaCreateInput = {
    id?: string
    idPessoa: string
    idEmpresa: string
    Pessoa?: PessoaCreateNestedOneWithoutUserEmpresaInput
  }

  export type UserEmpresaUncheckedCreateInput = {
    id?: string
    idPessoa: string
    idEmpresa: string
    pessoaId?: string | null
  }

  export type UserEmpresaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
    Pessoa?: PessoaUpdateOneWithoutUserEmpresaNestedInput
  }

  export type UserEmpresaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
    pessoaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserEmpresaCreateManyInput = {
    id?: string
    idPessoa: string
    idEmpresa: string
    pessoaId?: string | null
  }

  export type UserEmpresaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmpresaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
    pessoaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissaoCreateInput = {
    id?: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
    tipo: TipoCreateNestedOneWithoutPermissaoInput
    pessoa: PessoaCreateNestedOneWithoutPermissaoInput
  }

  export type PermissaoUncheckedCreateInput = {
    id?: string
    idTipo: string
    idPessoa: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
  }

  export type PermissaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo?: TipoUpdateOneRequiredWithoutPermissaoNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutPermissaoNestedInput
  }

  export type PermissaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PermissaoCreateManyInput = {
    id?: string
    idTipo: string
    idPessoa: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
  }

  export type PermissaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PermissaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContatoCreateInput = {
    id?: string
    descricao: string
    ativo?: boolean | null
    tipo: TipoCreateNestedOneWithoutContatoInput
    pessoa: PessoaCreateNestedOneWithoutContatoInput
  }

  export type ContatoUncheckedCreateInput = {
    id?: string
    idTipo: string
    idPessoa: string
    descricao: string
    ativo?: boolean | null
  }

  export type ContatoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo?: TipoUpdateOneRequiredWithoutContatoNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutContatoNestedInput
  }

  export type ContatoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContatoCreateManyInput = {
    id?: string
    idTipo: string
    idPessoa: string
    descricao: string
    ativo?: boolean | null
  }

  export type ContatoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContatoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TipoRelationFilter = {
    is?: TipoWhereInput | null
    isNot?: TipoWhereInput | null
  }

  export type PessoaListRelationFilter = {
    every?: PessoaWhereInput
    some?: PessoaWhereInput
    none?: PessoaWhereInput
  }

  export type EnderecoListRelationFilter = {
    every?: EnderecoWhereInput
    some?: EnderecoWhereInput
    none?: EnderecoWhereInput
  }

  export type PermissaoListRelationFilter = {
    every?: PermissaoWhereInput
    some?: PermissaoWhereInput
    none?: PermissaoWhereInput
  }

  export type ContatoListRelationFilter = {
    every?: ContatoWhereInput
    some?: ContatoWhereInput
    none?: ContatoWhereInput
  }

  export type PessoaTipoListRelationFilter = {
    every?: PessoaTipoWhereInput
    some?: PessoaTipoWhereInput
    none?: PessoaTipoWhereInput
  }

  export type TipoListRelationFilter = {
    every?: TipoWhereInput
    some?: TipoWhereInput
    none?: TipoWhereInput
  }

  export type PessoaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContatoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PessoaTipoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipoId?: SortOrder
    ativo?: SortOrder
  }

  export type TipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipoId?: SortOrder
    ativo?: SortOrder
  }

  export type TipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    tipoId?: SortOrder
    ativo?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PessoaRelationFilter = {
    is?: PessoaWhereInput
    isNot?: PessoaWhereInput
  }

  export type UserEmpresaListRelationFilter = {
    every?: UserEmpresaWhereInput
    some?: UserEmpresaWhereInput
    none?: UserEmpresaWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEmpresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PessoaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    inscricaoMunicipal?: SortOrder
    inscricaoEstadual?: SortOrder
    nascimento?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    isAdmin?: SortOrder
    tipoId?: SortOrder
    empresaId?: SortOrder
  }

  export type PessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    inscricaoMunicipal?: SortOrder
    inscricaoEstadual?: SortOrder
    nascimento?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    isAdmin?: SortOrder
    tipoId?: SortOrder
    empresaId?: SortOrder
  }

  export type PessoaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    inscricaoMunicipal?: SortOrder
    inscricaoEstadual?: SortOrder
    nascimento?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
    isAdmin?: SortOrder
    tipoId?: SortOrder
    empresaId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type PessoaTipoCountOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
  }

  export type PessoaTipoMaxOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
  }

  export type PessoaTipoMinOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
  }

  export type EnderecoCountOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    cep?: SortOrder
    local?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    complemento?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    principal?: SortOrder
  }

  export type EnderecoMaxOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    cep?: SortOrder
    local?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    complemento?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    principal?: SortOrder
  }

  export type EnderecoMinOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    cep?: SortOrder
    local?: SortOrder
    numero?: SortOrder
    bairro?: SortOrder
    complemento?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    ativo?: SortOrder
    principal?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    dataCadastro?: SortOrder
    dataAtualizado?: SortOrder
    ativo?: SortOrder
  }

  export type UserEmpresaCountOrderByAggregateInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    idEmpresa?: SortOrder
    pessoaId?: SortOrder
  }

  export type UserEmpresaMaxOrderByAggregateInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    idEmpresa?: SortOrder
    pessoaId?: SortOrder
  }

  export type UserEmpresaMinOrderByAggregateInput = {
    id?: SortOrder
    idPessoa?: SortOrder
    idEmpresa?: SortOrder
    pessoaId?: SortOrder
  }

  export type PermissaoCountOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    listar?: SortOrder
    cadastrar?: SortOrder
    editar?: SortOrder
    excluir?: SortOrder
  }

  export type PermissaoMaxOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    listar?: SortOrder
    cadastrar?: SortOrder
    editar?: SortOrder
    excluir?: SortOrder
  }

  export type PermissaoMinOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    listar?: SortOrder
    cadastrar?: SortOrder
    editar?: SortOrder
    excluir?: SortOrder
  }

  export type ContatoCountOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
  }

  export type ContatoMaxOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
  }

  export type ContatoMinOrderByAggregateInput = {
    id?: SortOrder
    idTipo?: SortOrder
    idPessoa?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
  }

  export type TipoCreateNestedOneWithoutTiposInput = {
    create?: XOR<TipoCreateWithoutTiposInput, TipoUncheckedCreateWithoutTiposInput>
    connectOrCreate?: TipoCreateOrConnectWithoutTiposInput
    connect?: TipoWhereUniqueInput
  }

  export type PessoaCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutTipoInput>, Enumerable<PessoaUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutTipoInput>
    createMany?: PessoaCreateManyTipoInputEnvelope
    connect?: Enumerable<PessoaWhereUniqueInput>
  }

  export type EnderecoCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutTipoInput>, Enumerable<EnderecoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutTipoInput>
    createMany?: EnderecoCreateManyTipoInputEnvelope
    connect?: Enumerable<EnderecoWhereUniqueInput>
  }

  export type PermissaoCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutTipoInput>, Enumerable<PermissaoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutTipoInput>
    createMany?: PermissaoCreateManyTipoInputEnvelope
    connect?: Enumerable<PermissaoWhereUniqueInput>
  }

  export type ContatoCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutTipoInput>, Enumerable<ContatoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutTipoInput>
    createMany?: ContatoCreateManyTipoInputEnvelope
    connect?: Enumerable<ContatoWhereUniqueInput>
  }

  export type PessoaTipoCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutTipoInput>, Enumerable<PessoaTipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutTipoInput>
    createMany?: PessoaTipoCreateManyTipoInputEnvelope
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
  }

  export type TipoCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<TipoCreateWithoutTipoInput>, Enumerable<TipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<TipoCreateOrConnectWithoutTipoInput>
    createMany?: TipoCreateManyTipoInputEnvelope
    connect?: Enumerable<TipoWhereUniqueInput>
  }

  export type PessoaUncheckedCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutTipoInput>, Enumerable<PessoaUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutTipoInput>
    createMany?: PessoaCreateManyTipoInputEnvelope
    connect?: Enumerable<PessoaWhereUniqueInput>
  }

  export type EnderecoUncheckedCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutTipoInput>, Enumerable<EnderecoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutTipoInput>
    createMany?: EnderecoCreateManyTipoInputEnvelope
    connect?: Enumerable<EnderecoWhereUniqueInput>
  }

  export type PermissaoUncheckedCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutTipoInput>, Enumerable<PermissaoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutTipoInput>
    createMany?: PermissaoCreateManyTipoInputEnvelope
    connect?: Enumerable<PermissaoWhereUniqueInput>
  }

  export type ContatoUncheckedCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutTipoInput>, Enumerable<ContatoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutTipoInput>
    createMany?: ContatoCreateManyTipoInputEnvelope
    connect?: Enumerable<ContatoWhereUniqueInput>
  }

  export type PessoaTipoUncheckedCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutTipoInput>, Enumerable<PessoaTipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutTipoInput>
    createMany?: PessoaTipoCreateManyTipoInputEnvelope
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
  }

  export type TipoUncheckedCreateNestedManyWithoutTipoInput = {
    create?: XOR<Enumerable<TipoCreateWithoutTipoInput>, Enumerable<TipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<TipoCreateOrConnectWithoutTipoInput>
    createMany?: TipoCreateManyTipoInputEnvelope
    connect?: Enumerable<TipoWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TipoUpdateOneWithoutTiposNestedInput = {
    create?: XOR<TipoCreateWithoutTiposInput, TipoUncheckedCreateWithoutTiposInput>
    connectOrCreate?: TipoCreateOrConnectWithoutTiposInput
    upsert?: TipoUpsertWithoutTiposInput
    disconnect?: boolean
    delete?: boolean
    connect?: TipoWhereUniqueInput
    update?: XOR<TipoUpdateWithoutTiposInput, TipoUncheckedUpdateWithoutTiposInput>
  }

  export type PessoaUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutTipoInput>, Enumerable<PessoaUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<PessoaUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: PessoaCreateManyTipoInputEnvelope
    set?: Enumerable<PessoaWhereUniqueInput>
    disconnect?: Enumerable<PessoaWhereUniqueInput>
    delete?: Enumerable<PessoaWhereUniqueInput>
    connect?: Enumerable<PessoaWhereUniqueInput>
    update?: Enumerable<PessoaUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<PessoaUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<PessoaScalarWhereInput>
  }

  export type EnderecoUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutTipoInput>, Enumerable<EnderecoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<EnderecoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: EnderecoCreateManyTipoInputEnvelope
    set?: Enumerable<EnderecoWhereUniqueInput>
    disconnect?: Enumerable<EnderecoWhereUniqueInput>
    delete?: Enumerable<EnderecoWhereUniqueInput>
    connect?: Enumerable<EnderecoWhereUniqueInput>
    update?: Enumerable<EnderecoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<EnderecoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<EnderecoScalarWhereInput>
  }

  export type PermissaoUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutTipoInput>, Enumerable<PermissaoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<PermissaoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: PermissaoCreateManyTipoInputEnvelope
    set?: Enumerable<PermissaoWhereUniqueInput>
    disconnect?: Enumerable<PermissaoWhereUniqueInput>
    delete?: Enumerable<PermissaoWhereUniqueInput>
    connect?: Enumerable<PermissaoWhereUniqueInput>
    update?: Enumerable<PermissaoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<PermissaoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<PermissaoScalarWhereInput>
  }

  export type ContatoUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutTipoInput>, Enumerable<ContatoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<ContatoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: ContatoCreateManyTipoInputEnvelope
    set?: Enumerable<ContatoWhereUniqueInput>
    disconnect?: Enumerable<ContatoWhereUniqueInput>
    delete?: Enumerable<ContatoWhereUniqueInput>
    connect?: Enumerable<ContatoWhereUniqueInput>
    update?: Enumerable<ContatoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<ContatoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<ContatoScalarWhereInput>
  }

  export type PessoaTipoUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutTipoInput>, Enumerable<PessoaTipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<PessoaTipoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: PessoaTipoCreateManyTipoInputEnvelope
    set?: Enumerable<PessoaTipoWhereUniqueInput>
    disconnect?: Enumerable<PessoaTipoWhereUniqueInput>
    delete?: Enumerable<PessoaTipoWhereUniqueInput>
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
    update?: Enumerable<PessoaTipoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<PessoaTipoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<PessoaTipoScalarWhereInput>
  }

  export type TipoUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<TipoCreateWithoutTipoInput>, Enumerable<TipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<TipoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<TipoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: TipoCreateManyTipoInputEnvelope
    set?: Enumerable<TipoWhereUniqueInput>
    disconnect?: Enumerable<TipoWhereUniqueInput>
    delete?: Enumerable<TipoWhereUniqueInput>
    connect?: Enumerable<TipoWhereUniqueInput>
    update?: Enumerable<TipoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<TipoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<TipoScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PessoaUncheckedUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutTipoInput>, Enumerable<PessoaUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<PessoaUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: PessoaCreateManyTipoInputEnvelope
    set?: Enumerable<PessoaWhereUniqueInput>
    disconnect?: Enumerable<PessoaWhereUniqueInput>
    delete?: Enumerable<PessoaWhereUniqueInput>
    connect?: Enumerable<PessoaWhereUniqueInput>
    update?: Enumerable<PessoaUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<PessoaUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<PessoaScalarWhereInput>
  }

  export type EnderecoUncheckedUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutTipoInput>, Enumerable<EnderecoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<EnderecoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: EnderecoCreateManyTipoInputEnvelope
    set?: Enumerable<EnderecoWhereUniqueInput>
    disconnect?: Enumerable<EnderecoWhereUniqueInput>
    delete?: Enumerable<EnderecoWhereUniqueInput>
    connect?: Enumerable<EnderecoWhereUniqueInput>
    update?: Enumerable<EnderecoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<EnderecoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<EnderecoScalarWhereInput>
  }

  export type PermissaoUncheckedUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutTipoInput>, Enumerable<PermissaoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<PermissaoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: PermissaoCreateManyTipoInputEnvelope
    set?: Enumerable<PermissaoWhereUniqueInput>
    disconnect?: Enumerable<PermissaoWhereUniqueInput>
    delete?: Enumerable<PermissaoWhereUniqueInput>
    connect?: Enumerable<PermissaoWhereUniqueInput>
    update?: Enumerable<PermissaoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<PermissaoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<PermissaoScalarWhereInput>
  }

  export type ContatoUncheckedUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutTipoInput>, Enumerable<ContatoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<ContatoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: ContatoCreateManyTipoInputEnvelope
    set?: Enumerable<ContatoWhereUniqueInput>
    disconnect?: Enumerable<ContatoWhereUniqueInput>
    delete?: Enumerable<ContatoWhereUniqueInput>
    connect?: Enumerable<ContatoWhereUniqueInput>
    update?: Enumerable<ContatoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<ContatoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<ContatoScalarWhereInput>
  }

  export type PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutTipoInput>, Enumerable<PessoaTipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<PessoaTipoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: PessoaTipoCreateManyTipoInputEnvelope
    set?: Enumerable<PessoaTipoWhereUniqueInput>
    disconnect?: Enumerable<PessoaTipoWhereUniqueInput>
    delete?: Enumerable<PessoaTipoWhereUniqueInput>
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
    update?: Enumerable<PessoaTipoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<PessoaTipoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<PessoaTipoScalarWhereInput>
  }

  export type TipoUncheckedUpdateManyWithoutTipoNestedInput = {
    create?: XOR<Enumerable<TipoCreateWithoutTipoInput>, Enumerable<TipoUncheckedCreateWithoutTipoInput>>
    connectOrCreate?: Enumerable<TipoCreateOrConnectWithoutTipoInput>
    upsert?: Enumerable<TipoUpsertWithWhereUniqueWithoutTipoInput>
    createMany?: TipoCreateManyTipoInputEnvelope
    set?: Enumerable<TipoWhereUniqueInput>
    disconnect?: Enumerable<TipoWhereUniqueInput>
    delete?: Enumerable<TipoWhereUniqueInput>
    connect?: Enumerable<TipoWhereUniqueInput>
    update?: Enumerable<TipoUpdateWithWhereUniqueWithoutTipoInput>
    updateMany?: Enumerable<TipoUpdateManyWithWhereWithoutTipoInput>
    deleteMany?: Enumerable<TipoScalarWhereInput>
  }

  export type EnderecoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutPessoaInput>, Enumerable<EnderecoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutPessoaInput>
    createMany?: EnderecoCreateManyPessoaInputEnvelope
    connect?: Enumerable<EnderecoWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<UserCreateWithoutPessoaInput>, Enumerable<UserUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPessoaInput>
    createMany?: UserCreateManyPessoaInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type PermissaoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutPessoaInput>, Enumerable<PermissaoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutPessoaInput>
    createMany?: PermissaoCreateManyPessoaInputEnvelope
    connect?: Enumerable<PermissaoWhereUniqueInput>
  }

  export type ContatoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutPessoaInput>, Enumerable<ContatoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutPessoaInput>
    createMany?: ContatoCreateManyPessoaInputEnvelope
    connect?: Enumerable<ContatoWhereUniqueInput>
  }

  export type TipoCreateNestedOneWithoutPessoaInput = {
    create?: XOR<TipoCreateWithoutPessoaInput, TipoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: TipoCreateOrConnectWithoutPessoaInput
    connect?: TipoWhereUniqueInput
  }

  export type PessoaTipoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutPessoaInput>, Enumerable<PessoaTipoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutPessoaInput>
    createMany?: PessoaTipoCreateManyPessoaInputEnvelope
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
  }

  export type PessoaCreateNestedOneWithoutEmpresaInput = {
    create?: XOR<PessoaCreateWithoutEmpresaInput, PessoaUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEmpresaInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutEmpresaInput>, Enumerable<PessoaUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutEmpresaInput>
    createMany?: PessoaCreateManyEmpresaInputEnvelope
    connect?: Enumerable<PessoaWhereUniqueInput>
  }

  export type UserEmpresaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<UserEmpresaCreateWithoutPessoaInput>, Enumerable<UserEmpresaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserEmpresaCreateOrConnectWithoutPessoaInput>
    createMany?: UserEmpresaCreateManyPessoaInputEnvelope
    connect?: Enumerable<UserEmpresaWhereUniqueInput>
  }

  export type EnderecoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutPessoaInput>, Enumerable<EnderecoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutPessoaInput>
    createMany?: EnderecoCreateManyPessoaInputEnvelope
    connect?: Enumerable<EnderecoWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<UserCreateWithoutPessoaInput>, Enumerable<UserUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPessoaInput>
    createMany?: UserCreateManyPessoaInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type PermissaoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutPessoaInput>, Enumerable<PermissaoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutPessoaInput>
    createMany?: PermissaoCreateManyPessoaInputEnvelope
    connect?: Enumerable<PermissaoWhereUniqueInput>
  }

  export type ContatoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutPessoaInput>, Enumerable<ContatoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutPessoaInput>
    createMany?: ContatoCreateManyPessoaInputEnvelope
    connect?: Enumerable<ContatoWhereUniqueInput>
  }

  export type PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutPessoaInput>, Enumerable<PessoaTipoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutPessoaInput>
    createMany?: PessoaTipoCreateManyPessoaInputEnvelope
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
  }

  export type PessoaUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutEmpresaInput>, Enumerable<PessoaUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutEmpresaInput>
    createMany?: PessoaCreateManyEmpresaInputEnvelope
    connect?: Enumerable<PessoaWhereUniqueInput>
  }

  export type UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<UserEmpresaCreateWithoutPessoaInput>, Enumerable<UserEmpresaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserEmpresaCreateOrConnectWithoutPessoaInput>
    createMany?: UserEmpresaCreateManyPessoaInputEnvelope
    connect?: Enumerable<UserEmpresaWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnderecoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutPessoaInput>, Enumerable<EnderecoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<EnderecoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: EnderecoCreateManyPessoaInputEnvelope
    set?: Enumerable<EnderecoWhereUniqueInput>
    disconnect?: Enumerable<EnderecoWhereUniqueInput>
    delete?: Enumerable<EnderecoWhereUniqueInput>
    connect?: Enumerable<EnderecoWhereUniqueInput>
    update?: Enumerable<EnderecoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<EnderecoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<EnderecoScalarWhereInput>
  }

  export type UserUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutPessoaInput>, Enumerable<UserUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: UserCreateManyPessoaInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type PermissaoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutPessoaInput>, Enumerable<PermissaoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<PermissaoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: PermissaoCreateManyPessoaInputEnvelope
    set?: Enumerable<PermissaoWhereUniqueInput>
    disconnect?: Enumerable<PermissaoWhereUniqueInput>
    delete?: Enumerable<PermissaoWhereUniqueInput>
    connect?: Enumerable<PermissaoWhereUniqueInput>
    update?: Enumerable<PermissaoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<PermissaoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<PermissaoScalarWhereInput>
  }

  export type ContatoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutPessoaInput>, Enumerable<ContatoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<ContatoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: ContatoCreateManyPessoaInputEnvelope
    set?: Enumerable<ContatoWhereUniqueInput>
    disconnect?: Enumerable<ContatoWhereUniqueInput>
    delete?: Enumerable<ContatoWhereUniqueInput>
    connect?: Enumerable<ContatoWhereUniqueInput>
    update?: Enumerable<ContatoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<ContatoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<ContatoScalarWhereInput>
  }

  export type TipoUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<TipoCreateWithoutPessoaInput, TipoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: TipoCreateOrConnectWithoutPessoaInput
    upsert?: TipoUpsertWithoutPessoaInput
    disconnect?: boolean
    delete?: boolean
    connect?: TipoWhereUniqueInput
    update?: XOR<TipoUpdateWithoutPessoaInput, TipoUncheckedUpdateWithoutPessoaInput>
  }

  export type PessoaTipoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutPessoaInput>, Enumerable<PessoaTipoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<PessoaTipoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: PessoaTipoCreateManyPessoaInputEnvelope
    set?: Enumerable<PessoaTipoWhereUniqueInput>
    disconnect?: Enumerable<PessoaTipoWhereUniqueInput>
    delete?: Enumerable<PessoaTipoWhereUniqueInput>
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
    update?: Enumerable<PessoaTipoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<PessoaTipoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<PessoaTipoScalarWhereInput>
  }

  export type PessoaUpdateOneWithoutEmpresaNestedInput = {
    create?: XOR<PessoaCreateWithoutEmpresaInput, PessoaUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEmpresaInput
    upsert?: PessoaUpsertWithoutEmpresaInput
    disconnect?: boolean
    delete?: boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutEmpresaInput, PessoaUncheckedUpdateWithoutEmpresaInput>
  }

  export type PessoaUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutEmpresaInput>, Enumerable<PessoaUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutEmpresaInput>
    upsert?: Enumerable<PessoaUpsertWithWhereUniqueWithoutEmpresaInput>
    createMany?: PessoaCreateManyEmpresaInputEnvelope
    set?: Enumerable<PessoaWhereUniqueInput>
    disconnect?: Enumerable<PessoaWhereUniqueInput>
    delete?: Enumerable<PessoaWhereUniqueInput>
    connect?: Enumerable<PessoaWhereUniqueInput>
    update?: Enumerable<PessoaUpdateWithWhereUniqueWithoutEmpresaInput>
    updateMany?: Enumerable<PessoaUpdateManyWithWhereWithoutEmpresaInput>
    deleteMany?: Enumerable<PessoaScalarWhereInput>
  }

  export type UserEmpresaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<UserEmpresaCreateWithoutPessoaInput>, Enumerable<UserEmpresaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserEmpresaCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<UserEmpresaUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: UserEmpresaCreateManyPessoaInputEnvelope
    set?: Enumerable<UserEmpresaWhereUniqueInput>
    disconnect?: Enumerable<UserEmpresaWhereUniqueInput>
    delete?: Enumerable<UserEmpresaWhereUniqueInput>
    connect?: Enumerable<UserEmpresaWhereUniqueInput>
    update?: Enumerable<UserEmpresaUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<UserEmpresaUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<UserEmpresaScalarWhereInput>
  }

  export type EnderecoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<EnderecoCreateWithoutPessoaInput>, Enumerable<EnderecoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<EnderecoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<EnderecoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: EnderecoCreateManyPessoaInputEnvelope
    set?: Enumerable<EnderecoWhereUniqueInput>
    disconnect?: Enumerable<EnderecoWhereUniqueInput>
    delete?: Enumerable<EnderecoWhereUniqueInput>
    connect?: Enumerable<EnderecoWhereUniqueInput>
    update?: Enumerable<EnderecoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<EnderecoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<EnderecoScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutPessoaInput>, Enumerable<UserUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: UserCreateManyPessoaInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type PermissaoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<PermissaoCreateWithoutPessoaInput>, Enumerable<PermissaoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PermissaoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<PermissaoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: PermissaoCreateManyPessoaInputEnvelope
    set?: Enumerable<PermissaoWhereUniqueInput>
    disconnect?: Enumerable<PermissaoWhereUniqueInput>
    delete?: Enumerable<PermissaoWhereUniqueInput>
    connect?: Enumerable<PermissaoWhereUniqueInput>
    update?: Enumerable<PermissaoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<PermissaoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<PermissaoScalarWhereInput>
  }

  export type ContatoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<ContatoCreateWithoutPessoaInput>, Enumerable<ContatoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<ContatoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<ContatoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: ContatoCreateManyPessoaInputEnvelope
    set?: Enumerable<ContatoWhereUniqueInput>
    disconnect?: Enumerable<ContatoWhereUniqueInput>
    delete?: Enumerable<ContatoWhereUniqueInput>
    connect?: Enumerable<ContatoWhereUniqueInput>
    update?: Enumerable<ContatoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<ContatoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<ContatoScalarWhereInput>
  }

  export type PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<PessoaTipoCreateWithoutPessoaInput>, Enumerable<PessoaTipoUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<PessoaTipoCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<PessoaTipoUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: PessoaTipoCreateManyPessoaInputEnvelope
    set?: Enumerable<PessoaTipoWhereUniqueInput>
    disconnect?: Enumerable<PessoaTipoWhereUniqueInput>
    delete?: Enumerable<PessoaTipoWhereUniqueInput>
    connect?: Enumerable<PessoaTipoWhereUniqueInput>
    update?: Enumerable<PessoaTipoUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<PessoaTipoUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<PessoaTipoScalarWhereInput>
  }

  export type PessoaUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<Enumerable<PessoaCreateWithoutEmpresaInput>, Enumerable<PessoaUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<PessoaCreateOrConnectWithoutEmpresaInput>
    upsert?: Enumerable<PessoaUpsertWithWhereUniqueWithoutEmpresaInput>
    createMany?: PessoaCreateManyEmpresaInputEnvelope
    set?: Enumerable<PessoaWhereUniqueInput>
    disconnect?: Enumerable<PessoaWhereUniqueInput>
    delete?: Enumerable<PessoaWhereUniqueInput>
    connect?: Enumerable<PessoaWhereUniqueInput>
    update?: Enumerable<PessoaUpdateWithWhereUniqueWithoutEmpresaInput>
    updateMany?: Enumerable<PessoaUpdateManyWithWhereWithoutEmpresaInput>
    deleteMany?: Enumerable<PessoaScalarWhereInput>
  }

  export type UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<UserEmpresaCreateWithoutPessoaInput>, Enumerable<UserEmpresaUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<UserEmpresaCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<UserEmpresaUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: UserEmpresaCreateManyPessoaInputEnvelope
    set?: Enumerable<UserEmpresaWhereUniqueInput>
    disconnect?: Enumerable<UserEmpresaWhereUniqueInput>
    delete?: Enumerable<UserEmpresaWhereUniqueInput>
    connect?: Enumerable<UserEmpresaWhereUniqueInput>
    update?: Enumerable<UserEmpresaUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<UserEmpresaUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<UserEmpresaScalarWhereInput>
  }

  export type TipoCreateNestedOneWithoutPessoaTipoInput = {
    create?: XOR<TipoCreateWithoutPessoaTipoInput, TipoUncheckedCreateWithoutPessoaTipoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutPessoaTipoInput
    connect?: TipoWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutPessoaTipoInput = {
    create?: XOR<PessoaCreateWithoutPessoaTipoInput, PessoaUncheckedCreateWithoutPessoaTipoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaTipoInput
    connect?: PessoaWhereUniqueInput
  }

  export type TipoUpdateOneRequiredWithoutPessoaTipoNestedInput = {
    create?: XOR<TipoCreateWithoutPessoaTipoInput, TipoUncheckedCreateWithoutPessoaTipoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutPessoaTipoInput
    upsert?: TipoUpsertWithoutPessoaTipoInput
    connect?: TipoWhereUniqueInput
    update?: XOR<TipoUpdateWithoutPessoaTipoInput, TipoUncheckedUpdateWithoutPessoaTipoInput>
  }

  export type PessoaUpdateOneRequiredWithoutPessoaTipoNestedInput = {
    create?: XOR<PessoaCreateWithoutPessoaTipoInput, PessoaUncheckedCreateWithoutPessoaTipoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaTipoInput
    upsert?: PessoaUpsertWithoutPessoaTipoInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutPessoaTipoInput, PessoaUncheckedUpdateWithoutPessoaTipoInput>
  }

  export type TipoCreateNestedOneWithoutEnderecoInput = {
    create?: XOR<TipoCreateWithoutEnderecoInput, TipoUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutEnderecoInput
    connect?: TipoWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutEnderecoInput = {
    create?: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEnderecoInput
    connect?: PessoaWhereUniqueInput
  }

  export type TipoUpdateOneRequiredWithoutEnderecoNestedInput = {
    create?: XOR<TipoCreateWithoutEnderecoInput, TipoUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutEnderecoInput
    upsert?: TipoUpsertWithoutEnderecoInput
    connect?: TipoWhereUniqueInput
    update?: XOR<TipoUpdateWithoutEnderecoInput, TipoUncheckedUpdateWithoutEnderecoInput>
  }

  export type PessoaUpdateOneRequiredWithoutEnderecoNestedInput = {
    create?: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEnderecoInput
    upsert?: PessoaUpsertWithoutEnderecoInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutEnderecoInput, PessoaUncheckedUpdateWithoutEnderecoInput>
  }

  export type PessoaCreateNestedOneWithoutUserInput = {
    create?: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserInput
    upsert?: PessoaUpsertWithoutUserInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutUserInput, PessoaUncheckedUpdateWithoutUserInput>
  }

  export type PessoaCreateNestedOneWithoutUserEmpresaInput = {
    create?: XOR<PessoaCreateWithoutUserEmpresaInput, PessoaUncheckedCreateWithoutUserEmpresaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserEmpresaInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneWithoutUserEmpresaNestedInput = {
    create?: XOR<PessoaCreateWithoutUserEmpresaInput, PessoaUncheckedCreateWithoutUserEmpresaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutUserEmpresaInput
    upsert?: PessoaUpsertWithoutUserEmpresaInput
    disconnect?: boolean
    delete?: boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutUserEmpresaInput, PessoaUncheckedUpdateWithoutUserEmpresaInput>
  }

  export type TipoCreateNestedOneWithoutPermissaoInput = {
    create?: XOR<TipoCreateWithoutPermissaoInput, TipoUncheckedCreateWithoutPermissaoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutPermissaoInput
    connect?: TipoWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutPermissaoInput = {
    create?: XOR<PessoaCreateWithoutPermissaoInput, PessoaUncheckedCreateWithoutPermissaoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPermissaoInput
    connect?: PessoaWhereUniqueInput
  }

  export type TipoUpdateOneRequiredWithoutPermissaoNestedInput = {
    create?: XOR<TipoCreateWithoutPermissaoInput, TipoUncheckedCreateWithoutPermissaoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutPermissaoInput
    upsert?: TipoUpsertWithoutPermissaoInput
    connect?: TipoWhereUniqueInput
    update?: XOR<TipoUpdateWithoutPermissaoInput, TipoUncheckedUpdateWithoutPermissaoInput>
  }

  export type PessoaUpdateOneRequiredWithoutPermissaoNestedInput = {
    create?: XOR<PessoaCreateWithoutPermissaoInput, PessoaUncheckedCreateWithoutPermissaoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPermissaoInput
    upsert?: PessoaUpsertWithoutPermissaoInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutPermissaoInput, PessoaUncheckedUpdateWithoutPermissaoInput>
  }

  export type TipoCreateNestedOneWithoutContatoInput = {
    create?: XOR<TipoCreateWithoutContatoInput, TipoUncheckedCreateWithoutContatoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutContatoInput
    connect?: TipoWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutContatoInput = {
    create?: XOR<PessoaCreateWithoutContatoInput, PessoaUncheckedCreateWithoutContatoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutContatoInput
    connect?: PessoaWhereUniqueInput
  }

  export type TipoUpdateOneRequiredWithoutContatoNestedInput = {
    create?: XOR<TipoCreateWithoutContatoInput, TipoUncheckedCreateWithoutContatoInput>
    connectOrCreate?: TipoCreateOrConnectWithoutContatoInput
    upsert?: TipoUpsertWithoutContatoInput
    connect?: TipoWhereUniqueInput
    update?: XOR<TipoUpdateWithoutContatoInput, TipoUncheckedUpdateWithoutContatoInput>
  }

  export type PessoaUpdateOneRequiredWithoutContatoNestedInput = {
    create?: XOR<PessoaCreateWithoutContatoInput, PessoaUncheckedCreateWithoutContatoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutContatoInput
    upsert?: PessoaUpsertWithoutContatoInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<PessoaUpdateWithoutContatoInput, PessoaUncheckedUpdateWithoutContatoInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type TipoCreateWithoutTiposInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutTiposInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutTiposInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutTiposInput, TipoUncheckedCreateWithoutTiposInput>
  }

  export type PessoaCreateWithoutTipoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutTipoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutTipoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutTipoInput, PessoaUncheckedCreateWithoutTipoInput>
  }

  export type PessoaCreateManyTipoInputEnvelope = {
    data: Enumerable<PessoaCreateManyTipoInput>
    skipDuplicates?: boolean
  }

  export type EnderecoCreateWithoutTipoInput = {
    id?: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
    pessoa: PessoaCreateNestedOneWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutTipoInput = {
    id?: string
    idPessoa: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
  }

  export type EnderecoCreateOrConnectWithoutTipoInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutTipoInput, EnderecoUncheckedCreateWithoutTipoInput>
  }

  export type EnderecoCreateManyTipoInputEnvelope = {
    data: Enumerable<EnderecoCreateManyTipoInput>
    skipDuplicates?: boolean
  }

  export type PermissaoCreateWithoutTipoInput = {
    id?: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
    pessoa: PessoaCreateNestedOneWithoutPermissaoInput
  }

  export type PermissaoUncheckedCreateWithoutTipoInput = {
    id?: string
    idPessoa: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
  }

  export type PermissaoCreateOrConnectWithoutTipoInput = {
    where: PermissaoWhereUniqueInput
    create: XOR<PermissaoCreateWithoutTipoInput, PermissaoUncheckedCreateWithoutTipoInput>
  }

  export type PermissaoCreateManyTipoInputEnvelope = {
    data: Enumerable<PermissaoCreateManyTipoInput>
    skipDuplicates?: boolean
  }

  export type ContatoCreateWithoutTipoInput = {
    id?: string
    descricao: string
    ativo?: boolean | null
    pessoa: PessoaCreateNestedOneWithoutContatoInput
  }

  export type ContatoUncheckedCreateWithoutTipoInput = {
    id?: string
    idPessoa: string
    descricao: string
    ativo?: boolean | null
  }

  export type ContatoCreateOrConnectWithoutTipoInput = {
    where: ContatoWhereUniqueInput
    create: XOR<ContatoCreateWithoutTipoInput, ContatoUncheckedCreateWithoutTipoInput>
  }

  export type ContatoCreateManyTipoInputEnvelope = {
    data: Enumerable<ContatoCreateManyTipoInput>
    skipDuplicates?: boolean
  }

  export type PessoaTipoCreateWithoutTipoInput = {
    id?: string
    pessoa: PessoaCreateNestedOneWithoutPessoaTipoInput
  }

  export type PessoaTipoUncheckedCreateWithoutTipoInput = {
    id?: string
    idPessoa: string
  }

  export type PessoaTipoCreateOrConnectWithoutTipoInput = {
    where: PessoaTipoWhereUniqueInput
    create: XOR<PessoaTipoCreateWithoutTipoInput, PessoaTipoUncheckedCreateWithoutTipoInput>
  }

  export type PessoaTipoCreateManyTipoInputEnvelope = {
    data: Enumerable<PessoaTipoCreateManyTipoInput>
    skipDuplicates?: boolean
  }

  export type TipoCreateWithoutTipoInput = {
    id?: string
    nome: string
    ativo?: boolean
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutTipoInput = {
    id?: string
    nome: string
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutTipoInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutTipoInput, TipoUncheckedCreateWithoutTipoInput>
  }

  export type TipoCreateManyTipoInputEnvelope = {
    data: Enumerable<TipoCreateManyTipoInput>
    skipDuplicates?: boolean
  }

  export type TipoUpsertWithoutTiposInput = {
    update: XOR<TipoUpdateWithoutTiposInput, TipoUncheckedUpdateWithoutTiposInput>
    create: XOR<TipoCreateWithoutTiposInput, TipoUncheckedCreateWithoutTiposInput>
  }

  export type TipoUpdateWithoutTiposInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutTiposInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type PessoaUpsertWithWhereUniqueWithoutTipoInput = {
    where: PessoaWhereUniqueInput
    update: XOR<PessoaUpdateWithoutTipoInput, PessoaUncheckedUpdateWithoutTipoInput>
    create: XOR<PessoaCreateWithoutTipoInput, PessoaUncheckedCreateWithoutTipoInput>
  }

  export type PessoaUpdateWithWhereUniqueWithoutTipoInput = {
    where: PessoaWhereUniqueInput
    data: XOR<PessoaUpdateWithoutTipoInput, PessoaUncheckedUpdateWithoutTipoInput>
  }

  export type PessoaUpdateManyWithWhereWithoutTipoInput = {
    where: PessoaScalarWhereInput
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyWithoutPessoaInput>
  }

  export type PessoaScalarWhereInput = {
    AND?: Enumerable<PessoaScalarWhereInput>
    OR?: Enumerable<PessoaScalarWhereInput>
    NOT?: Enumerable<PessoaScalarWhereInput>
    id?: StringFilter | string
    nome?: StringFilter | string
    documento?: StringNullableFilter | string | null
    razaoSocial?: StringNullableFilter | string | null
    nomeFantasia?: StringNullableFilter | string | null
    inscricaoMunicipal?: StringNullableFilter | string | null
    inscricaoEstadual?: StringNullableFilter | string | null
    nascimento?: DateTimeNullableFilter | Date | string | null
    dataCadastro?: DateTimeFilter | Date | string
    dataAtualizado?: DateTimeNullableFilter | Date | string | null
    ativo?: BoolNullableFilter | boolean | null
    isAdmin?: BoolNullableFilter | boolean | null
    tipoId?: StringNullableFilter | string | null
    empresaId?: StringNullableFilter | string | null
  }

  export type EnderecoUpsertWithWhereUniqueWithoutTipoInput = {
    where: EnderecoWhereUniqueInput
    update: XOR<EnderecoUpdateWithoutTipoInput, EnderecoUncheckedUpdateWithoutTipoInput>
    create: XOR<EnderecoCreateWithoutTipoInput, EnderecoUncheckedCreateWithoutTipoInput>
  }

  export type EnderecoUpdateWithWhereUniqueWithoutTipoInput = {
    where: EnderecoWhereUniqueInput
    data: XOR<EnderecoUpdateWithoutTipoInput, EnderecoUncheckedUpdateWithoutTipoInput>
  }

  export type EnderecoUpdateManyWithWhereWithoutTipoInput = {
    where: EnderecoScalarWhereInput
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type EnderecoScalarWhereInput = {
    AND?: Enumerable<EnderecoScalarWhereInput>
    OR?: Enumerable<EnderecoScalarWhereInput>
    NOT?: Enumerable<EnderecoScalarWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    cep?: StringFilter | string
    local?: StringFilter | string
    numero?: StringFilter | string
    bairro?: StringFilter | string
    complemento?: StringNullableFilter | string | null
    cidade?: StringFilter | string
    estado?: StringFilter | string
    ativo?: BoolNullableFilter | boolean | null
    principal?: BoolNullableFilter | boolean | null
  }

  export type PermissaoUpsertWithWhereUniqueWithoutTipoInput = {
    where: PermissaoWhereUniqueInput
    update: XOR<PermissaoUpdateWithoutTipoInput, PermissaoUncheckedUpdateWithoutTipoInput>
    create: XOR<PermissaoCreateWithoutTipoInput, PermissaoUncheckedCreateWithoutTipoInput>
  }

  export type PermissaoUpdateWithWhereUniqueWithoutTipoInput = {
    where: PermissaoWhereUniqueInput
    data: XOR<PermissaoUpdateWithoutTipoInput, PermissaoUncheckedUpdateWithoutTipoInput>
  }

  export type PermissaoUpdateManyWithWhereWithoutTipoInput = {
    where: PermissaoScalarWhereInput
    data: XOR<PermissaoUpdateManyMutationInput, PermissaoUncheckedUpdateManyWithoutPermissaoInput>
  }

  export type PermissaoScalarWhereInput = {
    AND?: Enumerable<PermissaoScalarWhereInput>
    OR?: Enumerable<PermissaoScalarWhereInput>
    NOT?: Enumerable<PermissaoScalarWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    listar?: BoolNullableFilter | boolean | null
    cadastrar?: BoolNullableFilter | boolean | null
    editar?: BoolNullableFilter | boolean | null
    excluir?: BoolNullableFilter | boolean | null
  }

  export type ContatoUpsertWithWhereUniqueWithoutTipoInput = {
    where: ContatoWhereUniqueInput
    update: XOR<ContatoUpdateWithoutTipoInput, ContatoUncheckedUpdateWithoutTipoInput>
    create: XOR<ContatoCreateWithoutTipoInput, ContatoUncheckedCreateWithoutTipoInput>
  }

  export type ContatoUpdateWithWhereUniqueWithoutTipoInput = {
    where: ContatoWhereUniqueInput
    data: XOR<ContatoUpdateWithoutTipoInput, ContatoUncheckedUpdateWithoutTipoInput>
  }

  export type ContatoUpdateManyWithWhereWithoutTipoInput = {
    where: ContatoScalarWhereInput
    data: XOR<ContatoUpdateManyMutationInput, ContatoUncheckedUpdateManyWithoutContatoInput>
  }

  export type ContatoScalarWhereInput = {
    AND?: Enumerable<ContatoScalarWhereInput>
    OR?: Enumerable<ContatoScalarWhereInput>
    NOT?: Enumerable<ContatoScalarWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
    descricao?: StringFilter | string
    ativo?: BoolNullableFilter | boolean | null
  }

  export type PessoaTipoUpsertWithWhereUniqueWithoutTipoInput = {
    where: PessoaTipoWhereUniqueInput
    update: XOR<PessoaTipoUpdateWithoutTipoInput, PessoaTipoUncheckedUpdateWithoutTipoInput>
    create: XOR<PessoaTipoCreateWithoutTipoInput, PessoaTipoUncheckedCreateWithoutTipoInput>
  }

  export type PessoaTipoUpdateWithWhereUniqueWithoutTipoInput = {
    where: PessoaTipoWhereUniqueInput
    data: XOR<PessoaTipoUpdateWithoutTipoInput, PessoaTipoUncheckedUpdateWithoutTipoInput>
  }

  export type PessoaTipoUpdateManyWithWhereWithoutTipoInput = {
    where: PessoaTipoScalarWhereInput
    data: XOR<PessoaTipoUpdateManyMutationInput, PessoaTipoUncheckedUpdateManyWithoutPessoaTipoInput>
  }

  export type PessoaTipoScalarWhereInput = {
    AND?: Enumerable<PessoaTipoScalarWhereInput>
    OR?: Enumerable<PessoaTipoScalarWhereInput>
    NOT?: Enumerable<PessoaTipoScalarWhereInput>
    id?: StringFilter | string
    idTipo?: StringFilter | string
    idPessoa?: StringFilter | string
  }

  export type TipoUpsertWithWhereUniqueWithoutTipoInput = {
    where: TipoWhereUniqueInput
    update: XOR<TipoUpdateWithoutTipoInput, TipoUncheckedUpdateWithoutTipoInput>
    create: XOR<TipoCreateWithoutTipoInput, TipoUncheckedCreateWithoutTipoInput>
  }

  export type TipoUpdateWithWhereUniqueWithoutTipoInput = {
    where: TipoWhereUniqueInput
    data: XOR<TipoUpdateWithoutTipoInput, TipoUncheckedUpdateWithoutTipoInput>
  }

  export type TipoUpdateManyWithWhereWithoutTipoInput = {
    where: TipoScalarWhereInput
    data: XOR<TipoUpdateManyMutationInput, TipoUncheckedUpdateManyWithoutTiposInput>
  }

  export type TipoScalarWhereInput = {
    AND?: Enumerable<TipoScalarWhereInput>
    OR?: Enumerable<TipoScalarWhereInput>
    NOT?: Enumerable<TipoScalarWhereInput>
    id?: StringFilter | string
    nome?: StringFilter | string
    tipoId?: StringNullableFilter | string | null
    ativo?: BoolFilter | boolean
  }

  export type EnderecoCreateWithoutPessoaInput = {
    id?: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
    tipo: TipoCreateNestedOneWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutPessoaInput = {
    id?: string
    idTipo: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
  }

  export type EnderecoCreateOrConnectWithoutPessoaInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutPessoaInput, EnderecoUncheckedCreateWithoutPessoaInput>
  }

  export type EnderecoCreateManyPessoaInputEnvelope = {
    data: Enumerable<EnderecoCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPessoaInput = {
    id?: string
    email: string
    password: string
    refreshToken?: string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
  }

  export type UserUncheckedCreateWithoutPessoaInput = {
    id?: string
    email: string
    password: string
    refreshToken?: string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
  }

  export type UserCreateOrConnectWithoutPessoaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPessoaInput, UserUncheckedCreateWithoutPessoaInput>
  }

  export type UserCreateManyPessoaInputEnvelope = {
    data: Enumerable<UserCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type PermissaoCreateWithoutPessoaInput = {
    id?: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
    tipo: TipoCreateNestedOneWithoutPermissaoInput
  }

  export type PermissaoUncheckedCreateWithoutPessoaInput = {
    id?: string
    idTipo: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
  }

  export type PermissaoCreateOrConnectWithoutPessoaInput = {
    where: PermissaoWhereUniqueInput
    create: XOR<PermissaoCreateWithoutPessoaInput, PermissaoUncheckedCreateWithoutPessoaInput>
  }

  export type PermissaoCreateManyPessoaInputEnvelope = {
    data: Enumerable<PermissaoCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type ContatoCreateWithoutPessoaInput = {
    id?: string
    descricao: string
    ativo?: boolean | null
    tipo: TipoCreateNestedOneWithoutContatoInput
  }

  export type ContatoUncheckedCreateWithoutPessoaInput = {
    id?: string
    idTipo: string
    descricao: string
    ativo?: boolean | null
  }

  export type ContatoCreateOrConnectWithoutPessoaInput = {
    where: ContatoWhereUniqueInput
    create: XOR<ContatoCreateWithoutPessoaInput, ContatoUncheckedCreateWithoutPessoaInput>
  }

  export type ContatoCreateManyPessoaInputEnvelope = {
    data: Enumerable<ContatoCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type TipoCreateWithoutPessoaInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutPessoaInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutPessoaInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutPessoaInput, TipoUncheckedCreateWithoutPessoaInput>
  }

  export type PessoaTipoCreateWithoutPessoaInput = {
    id?: string
    tipo: TipoCreateNestedOneWithoutPessoaTipoInput
  }

  export type PessoaTipoUncheckedCreateWithoutPessoaInput = {
    id?: string
    idTipo: string
  }

  export type PessoaTipoCreateOrConnectWithoutPessoaInput = {
    where: PessoaTipoWhereUniqueInput
    create: XOR<PessoaTipoCreateWithoutPessoaInput, PessoaTipoUncheckedCreateWithoutPessoaInput>
  }

  export type PessoaTipoCreateManyPessoaInputEnvelope = {
    data: Enumerable<PessoaTipoCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type PessoaCreateWithoutEmpresaInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutEmpresaInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutEmpresaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutEmpresaInput, PessoaUncheckedCreateWithoutEmpresaInput>
  }

  export type PessoaCreateManyEmpresaInputEnvelope = {
    data: Enumerable<PessoaCreateManyEmpresaInput>
    skipDuplicates?: boolean
  }

  export type UserEmpresaCreateWithoutPessoaInput = {
    id?: string
    idPessoa: string
    idEmpresa: string
  }

  export type UserEmpresaUncheckedCreateWithoutPessoaInput = {
    id?: string
    idPessoa: string
    idEmpresa: string
  }

  export type UserEmpresaCreateOrConnectWithoutPessoaInput = {
    where: UserEmpresaWhereUniqueInput
    create: XOR<UserEmpresaCreateWithoutPessoaInput, UserEmpresaUncheckedCreateWithoutPessoaInput>
  }

  export type UserEmpresaCreateManyPessoaInputEnvelope = {
    data: Enumerable<UserEmpresaCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type EnderecoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: EnderecoWhereUniqueInput
    update: XOR<EnderecoUpdateWithoutPessoaInput, EnderecoUncheckedUpdateWithoutPessoaInput>
    create: XOR<EnderecoCreateWithoutPessoaInput, EnderecoUncheckedCreateWithoutPessoaInput>
  }

  export type EnderecoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: EnderecoWhereUniqueInput
    data: XOR<EnderecoUpdateWithoutPessoaInput, EnderecoUncheckedUpdateWithoutPessoaInput>
  }

  export type EnderecoUpdateManyWithWhereWithoutPessoaInput = {
    where: EnderecoScalarWhereInput
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type UserUpsertWithWhereUniqueWithoutPessoaInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPessoaInput, UserUncheckedUpdateWithoutPessoaInput>
    create: XOR<UserCreateWithoutPessoaInput, UserUncheckedCreateWithoutPessoaInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPessoaInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPessoaInput, UserUncheckedUpdateWithoutPessoaInput>
  }

  export type UserUpdateManyWithWhereWithoutPessoaInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    idPessoa?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    dataCadastro?: DateTimeFilter | Date | string
    dataAtualizado?: DateTimeNullableFilter | Date | string | null
    ativo?: BoolNullableFilter | boolean | null
  }

  export type PermissaoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: PermissaoWhereUniqueInput
    update: XOR<PermissaoUpdateWithoutPessoaInput, PermissaoUncheckedUpdateWithoutPessoaInput>
    create: XOR<PermissaoCreateWithoutPessoaInput, PermissaoUncheckedCreateWithoutPessoaInput>
  }

  export type PermissaoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: PermissaoWhereUniqueInput
    data: XOR<PermissaoUpdateWithoutPessoaInput, PermissaoUncheckedUpdateWithoutPessoaInput>
  }

  export type PermissaoUpdateManyWithWhereWithoutPessoaInput = {
    where: PermissaoScalarWhereInput
    data: XOR<PermissaoUpdateManyMutationInput, PermissaoUncheckedUpdateManyWithoutPermissaoInput>
  }

  export type ContatoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: ContatoWhereUniqueInput
    update: XOR<ContatoUpdateWithoutPessoaInput, ContatoUncheckedUpdateWithoutPessoaInput>
    create: XOR<ContatoCreateWithoutPessoaInput, ContatoUncheckedCreateWithoutPessoaInput>
  }

  export type ContatoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: ContatoWhereUniqueInput
    data: XOR<ContatoUpdateWithoutPessoaInput, ContatoUncheckedUpdateWithoutPessoaInput>
  }

  export type ContatoUpdateManyWithWhereWithoutPessoaInput = {
    where: ContatoScalarWhereInput
    data: XOR<ContatoUpdateManyMutationInput, ContatoUncheckedUpdateManyWithoutContatoInput>
  }

  export type TipoUpsertWithoutPessoaInput = {
    update: XOR<TipoUpdateWithoutPessoaInput, TipoUncheckedUpdateWithoutPessoaInput>
    create: XOR<TipoCreateWithoutPessoaInput, TipoUncheckedCreateWithoutPessoaInput>
  }

  export type TipoUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type PessoaTipoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: PessoaTipoWhereUniqueInput
    update: XOR<PessoaTipoUpdateWithoutPessoaInput, PessoaTipoUncheckedUpdateWithoutPessoaInput>
    create: XOR<PessoaTipoCreateWithoutPessoaInput, PessoaTipoUncheckedCreateWithoutPessoaInput>
  }

  export type PessoaTipoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: PessoaTipoWhereUniqueInput
    data: XOR<PessoaTipoUpdateWithoutPessoaInput, PessoaTipoUncheckedUpdateWithoutPessoaInput>
  }

  export type PessoaTipoUpdateManyWithWhereWithoutPessoaInput = {
    where: PessoaTipoScalarWhereInput
    data: XOR<PessoaTipoUpdateManyMutationInput, PessoaTipoUncheckedUpdateManyWithoutPessoaTipoInput>
  }

  export type PessoaUpsertWithoutEmpresaInput = {
    update: XOR<PessoaUpdateWithoutEmpresaInput, PessoaUncheckedUpdateWithoutEmpresaInput>
    create: XOR<PessoaCreateWithoutEmpresaInput, PessoaUncheckedCreateWithoutEmpresaInput>
  }

  export type PessoaUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: PessoaWhereUniqueInput
    update: XOR<PessoaUpdateWithoutEmpresaInput, PessoaUncheckedUpdateWithoutEmpresaInput>
    create: XOR<PessoaCreateWithoutEmpresaInput, PessoaUncheckedCreateWithoutEmpresaInput>
  }

  export type PessoaUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: PessoaWhereUniqueInput
    data: XOR<PessoaUpdateWithoutEmpresaInput, PessoaUncheckedUpdateWithoutEmpresaInput>
  }

  export type PessoaUpdateManyWithWhereWithoutEmpresaInput = {
    where: PessoaScalarWhereInput
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type UserEmpresaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: UserEmpresaWhereUniqueInput
    update: XOR<UserEmpresaUpdateWithoutPessoaInput, UserEmpresaUncheckedUpdateWithoutPessoaInput>
    create: XOR<UserEmpresaCreateWithoutPessoaInput, UserEmpresaUncheckedCreateWithoutPessoaInput>
  }

  export type UserEmpresaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: UserEmpresaWhereUniqueInput
    data: XOR<UserEmpresaUpdateWithoutPessoaInput, UserEmpresaUncheckedUpdateWithoutPessoaInput>
  }

  export type UserEmpresaUpdateManyWithWhereWithoutPessoaInput = {
    where: UserEmpresaScalarWhereInput
    data: XOR<UserEmpresaUpdateManyMutationInput, UserEmpresaUncheckedUpdateManyWithoutUserEmpresaInput>
  }

  export type UserEmpresaScalarWhereInput = {
    AND?: Enumerable<UserEmpresaScalarWhereInput>
    OR?: Enumerable<UserEmpresaScalarWhereInput>
    NOT?: Enumerable<UserEmpresaScalarWhereInput>
    id?: StringFilter | string
    idPessoa?: StringFilter | string
    idEmpresa?: StringFilter | string
    pessoaId?: StringNullableFilter | string | null
  }

  export type TipoCreateWithoutPessoaTipoInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutPessoaTipoInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutPessoaTipoInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutPessoaTipoInput, TipoUncheckedCreateWithoutPessoaTipoInput>
  }

  export type PessoaCreateWithoutPessoaTipoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutPessoaTipoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutPessoaTipoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutPessoaTipoInput, PessoaUncheckedCreateWithoutPessoaTipoInput>
  }

  export type TipoUpsertWithoutPessoaTipoInput = {
    update: XOR<TipoUpdateWithoutPessoaTipoInput, TipoUncheckedUpdateWithoutPessoaTipoInput>
    create: XOR<TipoCreateWithoutPessoaTipoInput, TipoUncheckedCreateWithoutPessoaTipoInput>
  }

  export type TipoUpdateWithoutPessoaTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutPessoaTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type PessoaUpsertWithoutPessoaTipoInput = {
    update: XOR<PessoaUpdateWithoutPessoaTipoInput, PessoaUncheckedUpdateWithoutPessoaTipoInput>
    create: XOR<PessoaCreateWithoutPessoaTipoInput, PessoaUncheckedCreateWithoutPessoaTipoInput>
  }

  export type PessoaUpdateWithoutPessoaTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutPessoaTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type TipoCreateWithoutEnderecoInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutEnderecoInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutEnderecoInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutEnderecoInput, TipoUncheckedCreateWithoutEnderecoInput>
  }

  export type PessoaCreateWithoutEnderecoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutEnderecoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutEnderecoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput>
  }

  export type TipoUpsertWithoutEnderecoInput = {
    update: XOR<TipoUpdateWithoutEnderecoInput, TipoUncheckedUpdateWithoutEnderecoInput>
    create: XOR<TipoCreateWithoutEnderecoInput, TipoUncheckedCreateWithoutEnderecoInput>
  }

  export type TipoUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type PessoaUpsertWithoutEnderecoInput = {
    update: XOR<PessoaUpdateWithoutEnderecoInput, PessoaUncheckedUpdateWithoutEnderecoInput>
    create: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput>
  }

  export type PessoaUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaCreateWithoutUserInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutUserInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutUserInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
  }

  export type PessoaUpsertWithoutUserInput = {
    update: XOR<PessoaUpdateWithoutUserInput, PessoaUncheckedUpdateWithoutUserInput>
    create: XOR<PessoaCreateWithoutUserInput, PessoaUncheckedCreateWithoutUserInput>
  }

  export type PessoaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaCreateWithoutUserEmpresaInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
  }

  export type PessoaUncheckedCreateWithoutUserEmpresaInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type PessoaCreateOrConnectWithoutUserEmpresaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutUserEmpresaInput, PessoaUncheckedCreateWithoutUserEmpresaInput>
  }

  export type PessoaUpsertWithoutUserEmpresaInput = {
    update: XOR<PessoaUpdateWithoutUserEmpresaInput, PessoaUncheckedUpdateWithoutUserEmpresaInput>
    create: XOR<PessoaCreateWithoutUserEmpresaInput, PessoaUncheckedCreateWithoutUserEmpresaInput>
  }

  export type PessoaUpdateWithoutUserEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutUserEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type TipoCreateWithoutPermissaoInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Contato?: ContatoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutPermissaoInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutPermissaoInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutPermissaoInput, TipoUncheckedCreateWithoutPermissaoInput>
  }

  export type PessoaCreateWithoutPermissaoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Contato?: ContatoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutPermissaoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Contato?: ContatoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutPermissaoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutPermissaoInput, PessoaUncheckedCreateWithoutPermissaoInput>
  }

  export type TipoUpsertWithoutPermissaoInput = {
    update: XOR<TipoUpdateWithoutPermissaoInput, TipoUncheckedUpdateWithoutPermissaoInput>
    create: XOR<TipoCreateWithoutPermissaoInput, TipoUncheckedCreateWithoutPermissaoInput>
  }

  export type TipoUpdateWithoutPermissaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutPermissaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type PessoaUpsertWithoutPermissaoInput = {
    update: XOR<PessoaUpdateWithoutPermissaoInput, PessoaUncheckedUpdateWithoutPermissaoInput>
    create: XOR<PessoaCreateWithoutPermissaoInput, PessoaUncheckedCreateWithoutPermissaoInput>
  }

  export type PessoaUpdateWithoutPermissaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutPermissaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type TipoCreateWithoutContatoInput = {
    id?: string
    nome: string
    ativo?: boolean
    Tipo?: TipoCreateNestedOneWithoutTiposInput
    Pessoa?: PessoaCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutTipoInput
    Tipos?: TipoCreateNestedManyWithoutTipoInput
  }

  export type TipoUncheckedCreateWithoutContatoInput = {
    id?: string
    nome: string
    tipoId?: string | null
    ativo?: boolean
    Pessoa?: PessoaUncheckedCreateNestedManyWithoutTipoInput
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutTipoInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutTipoInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutTipoInput
    Tipos?: TipoUncheckedCreateNestedManyWithoutTipoInput
  }

  export type TipoCreateOrConnectWithoutContatoInput = {
    where: TipoWhereUniqueInput
    create: XOR<TipoCreateWithoutContatoInput, TipoUncheckedCreateWithoutContatoInput>
  }

  export type PessoaCreateWithoutContatoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    Endereco?: EnderecoCreateNestedManyWithoutPessoaInput
    User?: UserCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoCreateNestedManyWithoutPessoaInput
    Tipo?: TipoCreateNestedOneWithoutPessoaInput
    PessoaTipo?: PessoaTipoCreateNestedManyWithoutPessoaInput
    empresa?: PessoaCreateNestedOneWithoutEmpresaInput
    Empresa?: PessoaCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaCreateNestedManyWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutContatoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
    empresaId?: string | null
    Endereco?: EnderecoUncheckedCreateNestedManyWithoutPessoaInput
    User?: UserUncheckedCreateNestedManyWithoutPessoaInput
    Permissao?: PermissaoUncheckedCreateNestedManyWithoutPessoaInput
    PessoaTipo?: PessoaTipoUncheckedCreateNestedManyWithoutPessoaInput
    Empresa?: PessoaUncheckedCreateNestedManyWithoutEmpresaInput
    UserEmpresa?: UserEmpresaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutContatoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutContatoInput, PessoaUncheckedCreateWithoutContatoInput>
  }

  export type TipoUpsertWithoutContatoInput = {
    update: XOR<TipoUpdateWithoutContatoInput, TipoUncheckedUpdateWithoutContatoInput>
    create: XOR<TipoCreateWithoutContatoInput, TipoUncheckedCreateWithoutContatoInput>
  }

  export type TipoUpdateWithoutContatoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Tipo?: TipoUpdateOneWithoutTiposNestedInput
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutContatoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type PessoaUpsertWithoutContatoInput = {
    update: XOR<PessoaUpdateWithoutContatoInput, PessoaUncheckedUpdateWithoutContatoInput>
    create: XOR<PessoaCreateWithoutContatoInput, PessoaUncheckedCreateWithoutContatoInput>
  }

  export type PessoaUpdateWithoutContatoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Tipo?: TipoUpdateOneWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutContatoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaCreateManyTipoInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    empresaId?: string | null
  }

  export type EnderecoCreateManyTipoInput = {
    id?: string
    idPessoa: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
  }

  export type PermissaoCreateManyTipoInput = {
    id?: string
    idPessoa: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
  }

  export type ContatoCreateManyTipoInput = {
    id?: string
    idPessoa: string
    descricao: string
    ativo?: boolean | null
  }

  export type PessoaTipoCreateManyTipoInput = {
    id?: string
    idPessoa: string
  }

  export type TipoCreateManyTipoInput = {
    id?: string
    nome: string
    ativo?: boolean
  }

  export type PessoaUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Endereco?: EnderecoUpdateManyWithoutPessoaNestedInput
    User?: UserUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutPessoaNestedInput
    empresa?: PessoaUpdateOneWithoutEmpresaNestedInput
    Empresa?: PessoaUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    Endereco?: EnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    User?: UserUncheckedUpdateManyWithoutPessoaNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutPessoaNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutPessoaNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutPessoaNestedInput
    Empresa?: PessoaUncheckedUpdateManyWithoutEmpresaNestedInput
    UserEmpresa?: UserEmpresaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateManyWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnderecoUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pessoa?: PessoaUpdateOneRequiredWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EnderecoUncheckedUpdateManyWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PermissaoUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pessoa?: PessoaUpdateOneRequiredWithoutPermissaoNestedInput
  }

  export type PermissaoUncheckedUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PermissaoUncheckedUpdateManyWithoutPermissaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContatoUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pessoa?: PessoaUpdateOneRequiredWithoutContatoNestedInput
  }

  export type ContatoUncheckedUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContatoUncheckedUpdateManyWithoutContatoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PessoaTipoUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    pessoa?: PessoaUpdateOneRequiredWithoutPessoaTipoNestedInput
  }

  export type PessoaTipoUncheckedUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaTipoUncheckedUpdateManyWithoutPessoaTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
  }

  export type TipoUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateWithoutTipoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    Pessoa?: PessoaUncheckedUpdateManyWithoutTipoNestedInput
    Endereco?: EnderecoUncheckedUpdateManyWithoutTipoNestedInput
    Permissao?: PermissaoUncheckedUpdateManyWithoutTipoNestedInput
    Contato?: ContatoUncheckedUpdateManyWithoutTipoNestedInput
    PessoaTipo?: PessoaTipoUncheckedUpdateManyWithoutTipoNestedInput
    Tipos?: TipoUncheckedUpdateManyWithoutTipoNestedInput
  }

  export type TipoUncheckedUpdateManyWithoutTiposInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnderecoCreateManyPessoaInput = {
    id?: string
    idTipo: string
    cep: string
    local: string
    numero: string
    bairro: string
    complemento?: string | null
    cidade: string
    estado: string
    ativo?: boolean | null
    principal?: boolean | null
  }

  export type UserCreateManyPessoaInput = {
    id?: string
    email: string
    password: string
    refreshToken?: string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
  }

  export type PermissaoCreateManyPessoaInput = {
    id?: string
    idTipo: string
    listar?: boolean | null
    cadastrar?: boolean | null
    editar?: boolean | null
    excluir?: boolean | null
  }

  export type ContatoCreateManyPessoaInput = {
    id?: string
    idTipo: string
    descricao: string
    ativo?: boolean | null
  }

  export type PessoaTipoCreateManyPessoaInput = {
    id?: string
    idTipo: string
  }

  export type PessoaCreateManyEmpresaInput = {
    id?: string
    nome: string
    documento?: string | null
    razaoSocial?: string | null
    nomeFantasia?: string | null
    inscricaoMunicipal?: string | null
    inscricaoEstadual?: string | null
    nascimento?: Date | string | null
    dataCadastro?: Date | string
    dataAtualizado?: Date | string | null
    ativo?: boolean | null
    isAdmin?: boolean | null
    tipoId?: string | null
  }

  export type UserEmpresaCreateManyPessoaInput = {
    id?: string
    idPessoa: string
    idEmpresa: string
  }

  export type EnderecoUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo?: TipoUpdateOneRequiredWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    principal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PermissaoUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo?: TipoUpdateOneRequiredWithoutPermissaoNestedInput
  }

  export type PermissaoUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    listar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cadastrar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    editar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    excluir?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContatoUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipo?: TipoUpdateOneRequiredWithoutContatoNestedInput
  }

  export type ContatoUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PessoaTipoUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: TipoUpdateOneRequiredWithoutPessoaTipoNestedInput
  }

  export type PessoaTipoUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTipo?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    razaoSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoMunicipal?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tipoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserEmpresaUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmpresaUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmpresaUncheckedUpdateManyWithoutUserEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEmpresa?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}